#### الفصل الخامس

# الوراثة

الوراثة موضوع مهم في أغلب لغات البرمجة.

في اللغات الكلاسيكية (مثل لغة الجافا)، تقدم الوراثة -أو التمدد(extends)- خدمتان مهمتان جداً. الأُولى هي في أنها شكل من أشكال إعادة استخدام الشيفرة، فإذا كان الصنف الجديد يشبه الى حد كبير صنف آخر موجود، فما عليك سوى تعريف الاختلاف بينهما. أنماط إعادة استخدام الشيفرة مهمة جداً وذلك يرجع الى أن لديها قدرة عالية على التقليل من كلفة تطوير البرمجيات. The other benefit of classical inheritance is that it includes the specification of a system of types، وهذا يعفي المبرمج من الحاجة الى  التحويل بين الأنواع، والذي هو أمرٌ جيدٌ جداً ﻷن التحويل يلغي ميزة الأمان التي يقدمها نظام الأنواع.

وكون الجافا سكربت فضفاضة النوع، فهي لا تحتاج الى التحويل أصلاً، فأصل الكائن لا يهم، ما يهم هو ما الذي يستطيع ذاك الكائن فعله.

توفر الجافا سكربت مجموعة أغنى من أنماط إعادة الاستخدام. يمكنها تقليد الأنماط الكلاسيكية، ولكنها أيضاً تدعم أنماطاً أُخرى أكثر قوة. أنماط الوراثة الممكنة في الجافا سكربت متنوعة. وفي هذا الفصل، سنلقي نظرة على بعض الأنماط الواضحة والبسيطة منها. فالتطرُّق للأكثر تعقيداً ممكن، ولكن يفضل غالباً إبقاء الأمور بسيطةً.

في اللغات الكلاسيكية، يكون الكائن مستنسخاً من صنف ما، والصنف يمكن أن يرث من صنف آخر. لكن الجافا سكربت لغة نماذجيّة، ما يعني أن الكائن يرث مباشرةً من كائن آخر.

### الكلاسيكية الزائف

الجافا سكربت غير واثقة من طبيعتها النماذجية. فآلية الوراثة فيها مشوشة بسبب بعض الصيغ النحوية المعقدة التي تبدو وكأنها كلاسيكية. فبدلاً من جعل الكائنات ترث مباشرةً من كائنات أُخرى، هناك التفاف غير ضروري أٌدرج في المنتصف، مثل أن الكائنات تصنع بواسطة دوال بانية.

عندما يُنشأ كائن الدّالة، يقوم الباني الخاص بالكائن `Function` الذي يصنع كائن الدالة بتنفيذ هذه الشيفرة: 

```javascript
this.prototype = {constructor: this};
```

تم إعطاء كائن الدالة الجديد خاصية `prototype` والتي قيمتها عبارة عن كائن يحتوي على خاصية `construnctor` والذي قيمته نفس كائن الدالة الجديد. كائن النموذج هو المكان الذي تودع به السمات الموروثة. وجميع الدوال تحصل على كائن نماذجي لأن اللغة لا توفر أي طريقة لتحديد أيُ الدّوال سيتم استخدامها كبناة. الخاصيّة `constructor` غير مهمةـ إنما المهم هو الكائن `prototype`. 

عندما يتم استدعاء الدالة بواسطة نمط اتستدعاء الباني باستخدام السابقة `new`، تختلف الطريقة التي تنفذ بها الدالة. ولو أن `new` كان تابعاً بدلاً من كونه معاملاً، لكان سيتم كتابته كشيءٍ مثل هذا: 

````javascript
Function.method('new', function ( ) {
    // Create a new object that inherits from the
    // constructor's prototype.
     var that = Object.create(this.prototype);
    // Invoke the constructor, binding –this- to
    // the new object.
     var other = this.apply(that, arguments);
    // If its return value isn't an object,
    // substitute the new object.
     return (typeof other === 'object' && other) || that;
});
````

ونستطيع تعريف الباني وأن نعزز نموذجه:

```javascript
var Mammal = function (name) {
 this.name = name;
};
Mammal.prototype.get_name = function ( ) {
 return this.name;
};
Mammal.prototype.says = function ( ) {
 return this.saying || '';
};
```

الآن يمكننا عمل نسخة:

```javascript
var myMammal = new Mammal('Herb the Mammal');
var name = myMammal.get_name( ); // 'Herb the Mammal'
```

يمكننا عمل صنفٍ كاذبٍ آخر يقوم بالوراثة من `Mammal` من خلال تعريف الباني وإبدال نموذجه بنسخة من `Mammal`:

```javascript
var Cat = function (name) {
    this.name = name;
	this.saying = 'meow';
};
// Replace Cat.prototype with a new instance of Mammal
Cat.prototype = new Mammal( );
// Augment the new prototype with
// purr and get_name methods.
Cat.prototype.purr = function (n) {
    var i, s = '';
    for (i = 0; i < n; i += 1) {
        if (s) {
            s += '-';
        }
        s += 'r';
    }
    return s;
};
Cat.prototype.get_name = function ( ) {
	return this.says( ) + ' ' + this.name + ' ' + this.says( );
};
var myCat = new Cat('Henrietta');
var says = myCat.says( ); // 'meow'
var purr = myCat.purr(5); // 'r-r-r-r-r'
var name = myCat.get_name( );
// 'meow Henrietta meow'
```

وجد نمط الصنف الزائف هذا ليبدو نوعاً ما مثل الكائنية (Object oriented)، لكنه يبدو معقداً قليلاً. نستطيع إخفاء بعض التعقيد من خلال استخدامنا للتابع `method` وتعريفنا لتّابع الجديد `inherits`:

```javascript
Function.method('inherits', function (Parent) {
 this.prototype = new Parent( );
 return this;
});
```

التابعين `method` و `inherits` يرجعان `this` مما يسمح لنا بالكتابة باسلوب التتابع. فنستطيع الآن إنشاء الـ `Cat` في جملة واحدة:

```javascript
var Cat = function (name) {
    this.name = name;
    this.saying = 'meow';
}.
 inherits(Mammal).
 method('purr', function (n) {
     var i, s = '';
     for (i = 0; i < n; i += 1) {
         if (s) {
         	s += '-';
         }
     s += 'r';
     }
     return s;
 }).
 method('get_name', function ( ) {
	 return this.says( ) + ' ' + this.name + ' ' + this.says( );
 });	
```

بإخفائنا هرجة الـ `prototype`، أصبحت الشيفرة أقل تعقيداً. لكن هل حسّنا أي شيء فعلاً؟ لدينا الآن بانٍ يعمل مثل الأصناف، لكن هناك بعض الاختلافات، فلا يوجد خصوصية؛ جميع الخصائص علنيّة. وأيضاً ليس هناك وصولٌ الى التوابع الأعلى.

والأسوأ، أن هناك خطراً حقيقياً عند استخدام الباني، فإذا نسيت أن تستخدم  السابقة `new` عند استدعاء الباني، عندها لن يتم الربط بكائن جديد. للأسف، سيتم الربط بالكائن العام، أي بدلاً من تعزيز الكائن الجديد، ستقوم بالتخبط بالمتغيرات العامة. وهذا فعلاً سيء. وليس عناك أي تحذيرات أثناء الترجمة أو اثناء التشغيل.

هذه خطأ فادح في تصميم اللغة، وللتخفيف من هذه المشكلة، تم الاصطلاح على تسمية جميع الدوال البانية بحرف كبير في بداية الاسم، وعدم بدء اسم أي شيء آخر بحرف كبير. وهذا يرفع من فرص ملاحظة عدم استخدام `new`. لكن عدم استخدام `new` على الاطلاق حلُ أفضل بكثير.

يمكن أن يقدم نمط الأصناف الزائفة الراحة للمبرمجين غير المعتادين على لغة الجافا سكربت، لكنه يخفي الطبيعة الحقيقية للّغة، هذا الاسلوب يمكن أن يحث المبرمجين على تكوين تسلسلات هرمية عميقة بشكل غير ضروري ومعقدة . معظم التعقيد في البناء الهرمي للأصناف سببها القيود التحقق من الأنواع الثابتة. والجافا سكربت متحررة بالكامل من هذه القيود. في اللغات الكلاسيكية، وراثة الأصناف هي فقط شكل من أشكال إعادة الاستخدام. لكن الجافا سكربت توفر خيارات أكثر وأفضل.

### كائن المواصفات

في بعض الأحيان يلزم ارسال عدد كبير جداً من المعاملات الى الباني، وهذا يسبب اشكالاً حيث يصعب جداً تذكر ترتيب هذه الوسائط. في مثل هذه الحالة، يكون من الألطف جعل الباني يستقبل كائن مواصفات واحدٍ فقط. هذا الكائن يحوي على مواصفات الكائن الذي نريد بنائه. أي، بدلاً من هذا:

```javascript
var myObject = maker(f, l, m, c, s);
```

نستطيع كتابتة هذا:

```javascript
var myObject = maker({
 first: f,
 last: l,
 middle: m,
 state: s,
 city: c
});
```

فالآن يمكننا ارسال الوسائط بأي ترتيب، ويمكننا أيضاً إهمال إرسال اي وسيطة اذا كان الباني ذكياً بما يكفي فيما يتعلق بالقيم الأولية، وبهذا تكون الشيفرة أسهل للقراءة.

هذا قد يحمل لنا منافع جانبية عند التعامل مع الـ JSON -انظر الى الملحق ج-. فنص الـ JSON يمثل بيانات، واحياناً هذه البيانات تمثل كائن، وقد يكون من المفيد ارفاق البيانات بتوابعها. ويمكن فعل هذا بسهولة إذا كان الباني يستقبل كائن مواصفات لأننا ببساطة يمكننا ارسال الـ JSON الى الباني مباشرةً والذي بدوره سيرجع لنا كائناً كاملاً.

### النموذج

في النمط النماذجي الخالص، نستغني عن الأصناف ونركز بدلاً من ذلك على الكائنات. الوراثة النماذجية أسهل من الوراثة الكلاسيكية من حيث المفهوم، فالكائن الجديد يمكن أن يرث خصائص كائن آخر، هذا قد يكون غير مألوف، ولكنه حقاً سهل الفهم. تبدأ بانشاء كائن مفيد. بعدها يمكنك انشاء الكثير من الكائنات الأُخرى التي تشبه ذاك الكائن. وعملية تقسيم التطبيق الى مجموعة من الأصناف المجردة يمكن تلافيها نهائياً. 

دعنا نبدأ بستخدام التدوين الحرفي للكائن لصنع كائن مفيد:

```javascript
var myMammal = {
     name : 'Herb the Mammal',
     get_name : function ( ) {
     	return this.name;
     },
     says : function ( ) {
     	return this.saying || '';
     }
};
```

بمجرد حصولنا على كائن يعجبنا، يمكن أن ننشئ المزيد من النسخ باستخدام التابع `Object.create` من الفصل الثالث. وبعدها يمكننا تعديل النسخ الجديدة:

```javascript
var myCat = Object.create(myMammal);
myCat.name = 'Henrietta';
myCat.saying = 'meow';
myCat.purr = function (n) {
     var i, s = '';
     for (i = 0; i < n; i += 1) {
         if (s) {
         	s += '-';
         }
         s += 'r';
     }
     return s;
};
myCat.get_name = function ( ) {
	return this.says( ) + ' ' + this.name + ' ' + this.says( );
};
```

هذه وراثة تفاضلية (Differential inheritance)، فبتعديلنا على الكائن الجديد، نحدد الاختلافات عن الكائن الموروث. 

في بعض الأحيان يكون من المفيد لاحد هياكل البيانات أن يرث من هيكل بيانات آخر. وهنا مثال على ذلك: إفرض اننا نقوم بتحليل لغة مثل الجافا سكربت والتي تعبر فيها الخاصرتان عن النطاق. والعناصر المعرفة داخل النطاق لا ترى من خارجه. بمعنى، أن النطاق الداخلي يرث من النطاق الخارجي. وكائنات الجافا سكربت جيدة جداً في تمثيل هذه العلاقة. الدالة `blockc` نوديت بعد خاصرة الإغلاق. الدالة `parse` سوف تبحث عن 





