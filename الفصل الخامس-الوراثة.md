#### الفصل الخامس

# الوراثة

الوراثة موضوع مهم في أغلب لغات البرمجة.

في اللغات الكلاسيكية (مثل لغة الجافا)، تقدم الوراثة -أو التمدد(extends)- خدمتان مهمتان جداً. الأُولى هي في أنها شكل من أشكال إعادة استخدام الشيفرة، فإذا كان الصنف الجديد يشبه الى حد كبير صنف آخر موجود، فما عليك سوى تعريف الاختلاف بينهما. أنماط إعادة استخدام الشيفرة مهمة جداً وذلك يرجع الى أن لديها قدرة عالية على التقليل من كلفة تطوير البرمجيات. The other benefit of classical inheritance is that it includes the specification of a system of types، وهذا يعفي المبرمج من الحاجة الى  التحويل بين الأنواع، والذي هو أمرٌ جيدٌ جداً ﻷن التحويل يلغي ميزة الأمان التي يقدمها نظام الأنواع.

وكون الجافا سكربت فضفاضة النوع، فهي لا تحتاج الى التحويل أصلاً، فأصل الكائن لا يهم، ما يهم هو ما الذي يستطيع ذاك الكائن فعله.

توفر الجافا سكربت مجموعة أغنى من أنماط إعادة الاستخدام. يمكنها تقليد الأنماط الكلاسيكية، ولكنها أيضاً تدعم أنماطاً أُخرى أكثر قوة. أنماط الوراثة الممكنة في الجافا سكربت متنوعة. وفي هذا الفصل، سنلقي نظرة على بعض الأنماط الواضحة والبسيطة منها. فالتطرُّق للأكثر تعقيداً ممكن، ولكن يفضل غالباً إبقاء الأمور بسيطةً.

في اللغات الكلاسيكية، يكون الكائن مستنسخاً من صنف ما، والصنف يمكن أن يرث من صنف آخر. لكن الجافا سكربت لغة نماذجيّة، ما يعني أن الكائن يرث مباشرةً من كائن آخر.

### الكلاسيكية الزائف

الجافا سكربت غير واثقة من طبيعتها النماذجية. فآلية الوراثة فيها مشوشة بسبب بعض الصيغ النحوية المعقدة التي تبدو وكأنها كلاسيكية. فبدلاً من جعل الكائنات ترث مباشرةً من كائنات أُخرى، هناك التفاف غير ضروري أٌدرج في المنتصف، مثل أن الكائنات تصنع بواسطة دوال بانية.

عندما يُنشأ كائن الدّالة، يقوم الباني الخاص بالكائن `Function` الذي يصنع كائن الدالة بتنفيذ هذه الشيفرة: 

```javascript
this.prototype = {constructor: this};
```

تم إعطاء كائن الدالة الجديد خاصية `prototype` والتي قيمتها عبارة عن كائن يحتوي على خاصية `construnctor` والذي قيمته نفس كائن الدالة الجديد. كائن النموذج هو المكان الذي تودع به السمات الموروثة. وجميع الدوال تحصل على كائن نماذجي لأن اللغة لا توفر أي طريقة لتحديد أيُ الدّوال سيتم استخدامها كبناة. الخاصيّة `constructor` غير مهمةـ إنما المهم هو الكائن `prototype`. 

عندما يتم استدعاء الدالة بواسطة نمط اتستدعاء الباني باستخدام السابقة `new`، تختلف الطريقة التي تنفذ بها الدالة. ولو أن `new` كان تابعاً بدلاً من كونه معاملاً، لكان سيتم كتابته كشيءٍ مثل هذا: 

````javascript
Function.method('new', function ( ) {
    // Create a new object that inherits from the
    // constructor's prototype.
     var that = Object.create(this.prototype);
    // Invoke the constructor, binding –this- to
    // the new object.
     var other = this.apply(that, arguments);
    // If its return value isn't an object,
    // substitute the new object.
     return (typeof other === 'object' && other) || that;
});
````

ونستطيع تعريف الباني وأن نعزز نموذجه:

```javascript
var Mammal = function (name) {
 this.name = name;
};
Mammal.prototype.get_name = function ( ) {
 return this.name;
};
Mammal.prototype.says = function ( ) {
 return this.saying || '';
};
```

الآن يمكننا عمل نسخة:

```javascript
var myMammal = new Mammal('Herb the Mammal');
var name = myMammal.get_name( ); // 'Herb the Mammal'
```

يمكننا عمل صنفٍ كاذبٍ آخر يقوم بالوراثة من `Mammal` من خلال تعريف الباني وإبدال نموذجه بنسخة من `Mammal`:

```javascript
var Cat = function (name) {
    this.name = name;
	this.saying = 'meow';
};
// Replace Cat.prototype with a new instance of Mammal
Cat.prototype = new Mammal( );
// Augment the new prototype with
// purr and get_name methods.
Cat.prototype.purr = function (n) {
    var i, s = '';
    for (i = 0; i < n; i += 1) {
        if (s) {
            s += '-';
        }
        s += 'r';
    }
    return s;
};
Cat.prototype.get_name = function ( ) {
	return this.says( ) + ' ' + this.name + ' ' + this.says( );
};
var myCat = new Cat('Henrietta');
var says = myCat.says( ); // 'meow'
var purr = myCat.purr(5); // 'r-r-r-r-r'
var name = myCat.get_name( );
// 'meow Henrietta meow'
```

وجد نمط الصنف الكاذب هذا ليبدو نوعاً ما مثل الكائنية (Object oriented)، لكنه يبدو معقداً قليلاً. نستطيع إخفاء بعض التعقيد من خلال استخدامنا للتابع `method` وتعريفنا لتّابع الجديد `inherits`:

```javascript
Function.method('inherits', function (Parent) {
 this.prototype = new Parent( );
 return this;
});
```

التابعين `method` و `inherits` يرجعان `this` مما يسمح لنا بالكتابة باسلوب التتابع. فنستطيع الآن إنشاء الـ `Cat` في جملة واحدة:

```javascript
var Cat = function (name) {
    this.name = name;
    this.saying = 'meow';
}.
 inherits(Mammal).
 method('purr', function (n) {
     var i, s = '';
     for (i = 0; i < n; i += 1) {
         if (s) {
         	s += '-';
         }
     s += 'r';
     }
     return s;
 }).
 method('get_name', function ( ) {
	 return this.says( ) + ' ' + this.name + ' ' + this.says( );
 });	
```

بإخفائنا هرجة الـ `prototype`، أصبحت الشيفرة أقل تعقيداً. لكن هل حسّنا أي شيء فعلاً؟ لدينا الآن بانٍ يعمل مثل الأصناف، لكن هناك بعض الاختلافات، فلا يوجد خصوصية؛ جميع الخصائص علنيّة. وأيضاً ليس هناك وصولٌ الى التوابع الأعلى.

والأسوأ، أن هناك خطراً حقيقياً عند استخدام الباني، فإذا نسيت أن تستخدم  السابقة `new` عند استدعاء الباني، عندها لن يتم الربط بكائن جديد. للأسف، سيتم الربط بالكائن العام، أي بدلاً من تعزيز الكائن الجديد، ستقوم بالتخبط بالمتغيرات العامة. وهذا فعلاً سيء. وليس عناك أي تحذيرات أثناء الترجمة أو اثناء التشغيل.

هذه خطأ فادح في تصميم اللغة، وللتخفيف من هذه المشكلة، تم الاصطلاح على تسمية جميع الدوال البانية بحرف كبير في بداية الاسم، وعدم بدء اسم أي شيء آخر بحرف كبير. وهذا يرفع من فرص ملاحظة عدم استخدام `new`. لكن عدم استخدام `new` على الاطلاق حلُ أفضل بكثير.



