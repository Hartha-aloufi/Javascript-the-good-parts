#### الفصل الثالث

# الكائنات

الأنواع البسيطة في الجافا سكربت هي: الأرقام والسلاسل النصية والقيم البوليانية-`ture` `false`- و الـ`null` وأيضا الـ،`undefined`. وجميع القيم الأُخرى هي عبارةٌ عن كائنات. تعتبر الأرقام والسلاسل النصيَة شبيهةً بالكائنات من حيث امتلاكها للتوابع، غيرَ أنها ليست قابلة للتعديل(immutable). الكائنات في الجافا سكربت هي  are mutable keyed collections، في الجافا سكربت، المصفوفات كائنات، والدوال كائنات، والتعابير النمطية كائنات، وبالتأكيد أيضاً الكائنات كائنات. 

الكائن هو حاوية خصائص، حيث تمتلك الخاصيَة اسماً وقيمة، يمكن استخدام أي سلسلة نصية بما فيها السلسلة النصية الفارغة كاسم للخاصيَة. ويمكن استخدام أي قيمة في الجافا سكربت كقيمة للخاصيَة عدا الـ `undefined`. 

الكائنات في الجافا سكربت غير مرتبطة بأصناف(class-free). وليس هناك قيود على أسماء الخصائص أو قيمها. الكائنات مفيدة لجمع وتنظيم البيانات. يمكن أن يحوي الكائن على كائن آخر، وبذلك يكون من السهل تمثيل هياكل الأشجار والبروج(graphs).

تمتلك الجافا سكربت ميزة الربط النماذجي والتي تسمح للكائن بوراثة خصائص كائن آخر. وعندما تستخدم جيداً، يمكن أن تقلل من استهلاك الوقت والذاكرة اللازمين لتهيئة الكائنات.

### الكائن الحَرفي

الكائن الحرفي يقدم تدوين مناسباً جداً لإنشاء كائنات جديدة. الكائن الحرفي عبارة عن حاصرتان تحيطان بصفر أو أكثر من زَوجي "اسم:قيمة". ويمكن أن يوجد الكائن الحرفي في أي مكان يمكن أن يوجد فيه تعبير.

```javascript
var empty_object = {};
var stooge = {
 "first-name": "Jerome",
 "last-name": "Howard"
};
```

اسم الخاصية يمكن أن يكون أي سلسلة نصية بما يتضمن السلسلة النصية الفارغة، وعلامة التنصيص حول اسم الخاصية اختيارية بشرط أن يكون الاسم صالحاً وفق الجافا سكربت وأيضاً أن لا يكون كلمة محجوزة. لذا علامتي التنصيص إجبارية حول `"first-name"` واختيارية حول `first_name`. وتستخدم الفواصل للفصل بين الخصائص.

يمكن الحصول على قيم الخصائص من أي تعبير، بما في ذلك الكائنات الحرفية. حيث يصبح الكائن متداخلاً:

```javascript
var flight = {
     airline: "Oceanic",
     number: 815,
     departure: {
         IATA: "SYD",
         time: "2004-09-22 14:55",
         city: "Sydney"
     },
     arrival: {
         IATA: "LAX",
         time: "2004-09-23 10:42",
         city: "Los Angeles"
     }
};
```

### الاسترجاع

يمكن استرجاع القيم من الكائنات بكاتبة تعبير نَصّي -أي أيٌّ تعبير يٌنتج سلسلة نصيّة- داخل زوجين من الأقواس المعقوفة `[]` تَلحق اسم الكائن. وإذا كان التعبير النَصّي سلسلة نصيّة حرفية لا تخالف قواعد الأسماء في الجافا سكربت ولا هي كلمة محجوزة فعندها يمكن استخدام رمز النقطة `.`، وهي طريقة أفضل حيث أنها أكثر إحكاماً وأسهل للقراءة: 

```javascript
stooge["first-name"]  // "Jerome"
flight.departure.IATA // "SYD"

```

ستحصل على قيمة `undefined` إذا حاولت استرجاع قيمة لخاصية غير موجودة:

```javascript
stooge["middle-name"] // undefined
flight.status         // undefined
stooge["FIRST-NAME"]  // undefined
```

 

 يمكن استخدام العامل المنطقي "أو" `||` لتعين قيم افتراضية:

```javascript
var middle = stooge["middle-name"] || "(none)";
var status = flight.status         || "unknown";
```

 محاولة استرجاع قيم من الـ `undefined` سيؤدي الى رمي اعتراض(exception) من نوع `TypeError`. ويمكن التحصن ضده باستخدام العامل المنطقي "و" `&&`:

```javascript
flight.equipment						   // undefined
flight.equipment.model 				       // رمي اعتراض "TypeError"
flight.equipment && flight.equipment.model // undefined
```

### التحديث

يمكن تحديث قيمة في كائن ما من خلال الإسناد. فإذا كانت الخاصية موجودة مسبقاً في الكائن، فسيتم استبدالها: 

```javascript
stooge['first-name'] = 'Jerome';
```

وإذا لم تكن الخاصية موجودة مسبقاً في الكائن، فسيتم اضافتها:

```javascript
stooge['middle-name'] = 'Lester';
stooge.nickname = 'Curly';
flight.equipment = {
 model: 'Boeing 777'
};
flight.status = 'overdue';
```

### المرجع

تمرر الكائنات بواسطة مرجعها فلا يتم نسخها ابداً عند التمرير: 

```javascript
var x = stooge;
x.nickname = 'Curly';
var nick = stooge.nickname;
 //قيمة المتغير nick هي 'Culry' لأن x و stooge
 // هما مرجعين لنفس الكائن
var a = {}, b = {}, c = {};
 //كل المتغيرات السابقة تشير الى
 // كائنات فارغة مختلفة
a = b = c = {};
 // كل المتغيرات السابقة تشير الى
 // نفس المتغير الفارغ

```

### النموذج

كل الكائنات مربوطة بكائن نماذجي والتي يمكن أن ترث الخصائص منه. حيث أن كل الكائنات المنشأة بكائنات حرفية مرتبطة ب `Object.prototype` وهو كائن يأتي ضمن الجافا سكربت نفسها.

عندما تقوم بإنشاء كائن جديد، يمكنك اختيار الكائن الذي سيكون نموذجه. الآلية التي تقدمها الجافا سكربت لتنفيذ هذا فوضوية ومعقدة، لكن يمكن تبسيطها بشكل فعال. سنقوم بإضافة تابع `create` للدالة `Object`. 



```javascript
if (typeof Object.create !== 'function') {
    Object.create = function (o) {
        var F = function () {};
        F.prototype = o;
        return new F();
    };
}
var another_stooge = Object.create(stooge);
```

 لا يملك الرابط النماذجي أي تأثير على التحديثات، أي عندما نقوم بإجراء تعديل على كائن ما، لا يتم مس نموذج ذلك الكائن ولا يتأثر بالتحديث:

```javascript
another_stooge['first-name'] = 'Harry';
another_stooge['middle-name'] = 'Moses';
another_stooge.nickname = 'Moe';
```

يُستخدم الرابط النماذجي فقط في الاسترجاع، فعندما نحاول استرجاع قيمةَ خاصيةٍ من كائن ما، وذلك الكائن يفتقر  الى تلك الخاصية، عندها تقوم الجافا سكربت بمحاولة استرجاع تلك القيمة من الكائن النماذجي، وإن كان ذلك الكائن أيضاً يفتقر الى تلك الخاصية، فسنستمر الى نموذج الذي بعده، وهكذا حتى ننتهي إلى `Object.prototype`. فإذا لم نجد تلك الخاصية في كامل سلسلة النماذج، فستكون القيمة هي `undefined`. وهذا ما يدعى بالتفويض(delegation). 

العلاقة النماذجية علاقة ديناميكية، فإذا اضفنا خاصية جديدة الى أحد النماذج، فستكون تلك الخاصية مرئية لجميع الكائنات المعتمدة على ذلك النموذج:

```javascript
stooge.profession = 'actor';
another_stooge.profession // 'actor'
```

سوف نرى المزيد عن سلسلة النماذج في الفصل السادس.

### التفحص

من السهل تفحص كائن ما لمعرفة الخصائص التي يمتلكها وذلك بمحاولة استرجاعها ومعرفة قيمها. وعامل الـ`typeof` مفيد جدا في تحديد نوع الخصائص:

```javascript
typeof flight.number   // 'number'
typeof flight.status   // 'string'
typeof flight.arrival  // 'object'
typeof flight.manifest // 'undefined'
```

ومن الضروري توخي الحذر هنا لأن الـ `typeof` تبحث أيضاً في سلسلة النماذج:

```javascript
typeof flight.toString    // 'function'
typeof flight.constructor // 'function'
```

هناك طريقتين للتجنب هذه الخصائص غير المرغوبة.The first is to have your program look for and reject function values. Generally, when you are reflecting, you are interested in data, and so you should be aware that some values could be functions.

الطريقة الثانية هي باستخدام التابع `hasOwnProperty`، والتي ترجع قيمة `true` إذا كانت الخاصية موجودة مباشرة في الكائن نفسه ولا تبحث في سلسلة النماذج:

 ```javascript
 flight.hasOwnProperty('number')      // true
 flight.hasOwnProperty('constructor') // false
 ```

### التعداد

تسطيع جملة for in الدوران على جميع الخصائص في كائن ما. وهذه الدوران يشمل جميع الخصائص والدوال وخصائص النماذج والتي قد لا تهمك، لذا فإنه من الضروري تصفية القيم التي لا تريدها. أكثر أساليب التصفية شيوعاً هي باستخدام التابع `hasOwnProperty` واستخدام العامل `typeof` لاستبعاد الدوال:

```javascript
var name;
for (name in another_stooge) {
 if (typeof another_stooge[name] !== 'function') {
 document.writeln(name + ': ' + another_stooge[name]);
 }
}
```

ليس هناك أي ضمانة على ترتيب الأسماء، لذا كن مستعداً للدوران على الخصائص بأي ترتيب كان. إذا كنت تريد أن تتعامل مع الأسماء بترتيب معين، فالأفضل تجنب استخدام جملة الدوران for in كلياً، وعوضاً عن ذلك أنشئ مصفوفة تحوي جميع أسماء الخصائص التي تريدها وبالترتيب الذي تريد:

 ```javascript
 var i;
 var properties = [
  'first-name',
  'middle-name',
  'last-name',
  'profession'
 ];
 for (i = 0; i < properties.length; i += 1) {
  document.writeln(properties[i] + ': ' +
  another_stooge[properties[i]]);
 }
 ```

باستخدامنا لجملة الدوران `for` بدلا من for in، فقد استطعنا الحصول على الخصائص التي نريدها بالترتيب الذي نريد  دون أن نقلق من احتمالية حصولنا على خصائص لا نريدها من سلسلة النماذج.

### الحذف

يٌستخدم عامل الحذف `delete` لحذف الخصائص من الكائنات. حيث يقوم بحذف الخاصية إن وجدت في الكائن نفسه، ولكن لن يتمَ مَسٌ أيِّ كائنٍ في السلسلة النماذجية.

حذف خاصية من كائن ما قد تفسح المجال لخاصية موجودة فعلاً في السلسلة النماذجية وجعلها تظهر:

```javascript
another_stooge.nickname // 'Moe'
// حذف الخاصية nickname من الكائن another_stooge سيظهر
// خاصية نموذجه التي تحمل نفس الاسم nickname.
delete another_stooge.nickname;
another_stooge.nickname // 'Curly'

```

### حسر النطاق العام

جعلت الجافا سكربت أمر تعريف متغيرات عامة تحفظ جميع أٌصول(assets) التطبيق أمراً سهلاً. لكن للأسف، المتغيرات العامة تقلل من مرونة البرنامج ويجب تجنبها.

أحد طرق تقليل استخدام المتغيرات العامة هي بإنشاء متغير عام واحد لكامل تطبيقك:

```javascript
var MYAPP = {};
```

وهذا المتغير سيكون بمثابة حاوية تجمع كامل التطبيق:

```javascript
MYAPP.stooge = {
 "first-name": "Joe",
 "last-name": "Howard"
};
MYAPP.flight = {
 airline: "Oceanic",
 number: 815,
 departure: {
 IATA: "SYD",
 time: "2004-09-22 14:55",
 city: "Sydney"
 },
 arrival: {
 IATA: "LAX",
 time: "2004-09-23 10:42",
 city: "Los Angeles"
 }
};
```

من خلال حصر المتغيرات العالمة وقصرها على متغير واحد فإننا بذلك نقلل من احتمالية التضارب مع تطبيقات أو مكتبات أٌخرى، وأيضاً بذلك يصبح البرنامج أسهل للقراءة لأنه من الواضح أن `MYAPP.stooge` يمثل كيان مستوى أعلا. نتعرف في الفصل القادم على المٌغلِّف(closure) لإخفاء المعلومات، والذي هو تقنية حسرٌ نطاق عام فعّالة. 
