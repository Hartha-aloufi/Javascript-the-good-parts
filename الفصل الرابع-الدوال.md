#### الفصل الرابع

# الدوال



أفضل ما في الجافا سكربت هو تطبيقها للدوال. فلقد أتمت كل شيء تقريباً بشكل صحيح. لكن، وكما يمكن أن تتوقع من الجافا سكربت، فهي لم تُتم كل شيء تماماً بشكل صحيح.

الدالة تشتمل على مجموعة من الجمل. وهي الوِحدة الأساسية في الجافا سكربت. فهي تُستَخدَمُ لإخفاء المعلومات(information hiding) وإعادة استخدام الشيفرة(code reuse) والتكوين(composition). تستخدم الدوال لتحديد سلوك الكائنات. بشكل عام، صنعة البرمجة هي تحويل مجموعة من المتطلبات الى مجموعة من الدوال وهياكل البيانات. 

### كائنات الدوال

في الجافا سكربت الدوال كائنات، والكائن هو تجميعة من زوجي "اسم/قيمة" يمتلك رابطاً خفياً الى كائن نماذجي(prototype object). والكائنات الناشئة من كائن حرفي مرتبطة ب `Object.prototype`. أما كائنات الدوال فمرتبطة ب `Function.prototype` والذي هو بدووره مرتبطٌ ب `Object.prototype`. كل الدوال تمتلك خاصيتين إضافيتين تنشئان معها: سياق الدالة(context) والشيفرة التي تطبق سلوك الدالة.

جميع كائنات الدوال تمتلك خاصية `prototype` تنشأ معها. قيمتها كائن يحوي خاصية تسمى `constructor` -أي الباني من كلمة بناء- والتي قيمتها الدالة نفسها. وهذا مختلف عن الرابط الخفيّ لـ `Function.prototype`. سيتم شرح المعنى الشائك لهذا الباني في الفصل القادم.

بما أن الدوال هي كائنات، فيمكن معاملتها مثل أي قيمة أٌخرى. الدوال يمكن تخزينها في المتغيرات والمصفوفات والكائنات. الدوال يمكن تمريرها كوسائط لدوالٍ أٌخرى. وأيضاً، بما أن الدوال هي في الأصل كائنات، فيمكنها أن تمتلك توابع. لكن الأمر المميز في الدوال هو إمكانية استدعائها.



### الدالة الحرفيّة

كائنات الدوال تنشئ بواسطة الدوال الحرفية:

```javascript
// أنشء متغاً باسم add وخزن به دالة
// تقوم بجمع رقمين
var add = function (a, b) {
 return a + b;
};
```

الدالة الحرفية تمتلك أربعة أجزاء. الجزء الأول هو الكلمة المحجوزة `function`. 

الجزء الثاني اختياري، وهو اسم الدالة. ويمكن للدالة استخدامُ ذلك الاسم لمناداة نفسها عَوْدياً(recursively). ويستخدم الاسم أيضاً بواسطة المصححات(debugger) وأدوات التطوير(development tools) للتعرف على الدالة. إذا لم يعطى للدالة اسم كما في المثال السابق، فعندها تسمى "دالة مجهولة"(anonymous).

الجزء الثالث هو مجموعة الوسائط الخاصة بالدالة، محاطة بأقواس ويُفصل بينها بالفواصل. وهذه الوسائط سيتم تعريفها كمتغيرات في الدالة. وعلى عكس المتغيرات العادية التي يتم تهيئتها بقيمة `undefined` فإنها تهيَّأ بقيمة الوسائط المرسلة عند استدعاء الدالة.

الجزء الرابع هو مجموعة من الكلمات محاطة بخاصرتين، هذه الجمل هي جسم الدالة. ويتم تنفيذها عند استدعاء الدالة.

يمكن للدالة الحرفية أن تظهر في أي مكان تظهر فيه التعابير. وأيضاً يمكن تعريف الدالّة داخل دالة أُخرى. بالطبع يكون لهذه الدالة وسائط ومتغيرات خاصة بها. وللدالة الداخلية القدرة على الوصول لوسائط ومتغيرات الدالة الخارجية أيضاً. يحتوي كائن الدالة المُنشئ بواسطة الدالة الحرفية على رابط للسياق الخارجي(outer context). وهذا يدعى بالمغلف(closure) وهو مصدر لقوة هائلة. 

### الاستدعاء

استدعاء الدالة يعلق تنفيذ الدالة الحالية ويمرر التحكم والعوامل(parameters) للدالة الجديدة. بالإضافة الى العوامل المصرح بها، تستقبل كل الدوال عاملين إضافيين: `this` و`arguments`. العامل `this` مهم جداً في البرمجة كائنية التوجه، وقيمتها تُحدد بنمط استدعائها. هناك أربع أنماط للاستدعاء في الجافا سكربت: نمط استدعاء التابع، نمط استدعاء الدالة، نمط استدعاء الباني، ونمط الاستدعاء باستخدام `apply`. وتختلف الأنماط بكيفية العامل الإضافي `this`.

عامل الاستدعاء هو عبارة عن زوجين من الأقواس يتبعان أي تعبير ينتج دالة. قد تحوي الأقواس على صفر أو أكثر من التعابير تفصل بينها الفواصل. وكل تعبيرٍ ينتج قيمة وسيطة واحدة. وكل وسيطة سيتم إسنادها الى معامل واحد. ولا يلزم أن تكون عدد الوسائط مساوياً لعدد المعاملات. فإذا كان عدد الوسائط أكثر فسيتم تجاهل الوسائط الزائدة. أما إذا كان عددها أقل، فسيتم إعطاء المعاملات الباقية قيمة `undefined`. لا يتم تنفيذ التحقق من الأنواع(type checking) على قيم الوسائط حيث أن أي نوع من القيم يمكن أن يرسل لأي معامل.

###  نمط استدعاء التابع

نسمي الدالة تابعاً إذا كانت جزءً من كائن، وعند استدعاء التابع تمثل الجملة `this` ذلك الكائن. فإذا احتوى الاستدعاء على تنقيح- النقطة . أو الأقواس المعقوفة []- عندها يكون اللاستدعاء بنمط التابع.

```javascript
// Create myObject. It has a value and an increment
// method. The increment method takes an optional
// parameter. If the argument is not a number, then 1
// is used as the default.
var myObject = {
    value: 0,
    increment: function (inc) {
	this.value += typeof inc === 'number' ? inc : 1;
 	}
};
myObject.increment( );
document.writeln(myObject.value); // 1
myObject.increment(2);
document.writeln(myObject.value); // 3
```

يستطيع التابع استخدام  `this` للوصول الى الكائن واسترجاع القيم منه أو تعديلها، حيث يتم ربط `this` بالكائن خلال وقت الاستدعاء. وهذا الربط يجعل من الدوال التي تستخدم `this` قابلة لإعداة الاستخدام بدرجة عالية. التوابع التي تصل الى سياق كائنها من خلال `this` تسمى توابع علنيّة(public methods).

### نمط استدعاء الدالة

عندما لا تكون الدالة خاصية في كائن ما، عندها تستدعا كدالة:

```javascript
var sum = add(3, 4); // sum يساوي 7	
```

عندما تستدعى الدالة بهذا النمط تربط  `this` بالكائن العام. وهذا خطأٌ في تصميم اللغة. والصواب في حال استدعاء الدوال الداخلية-دالة داخل دالة أُخرى- أن تربط `this` الخاصة بها ب`this` الخاصة بالدالة الخارجية. وما ترتب على هذا الخطأ أن التوابع لا تستطيع توظيف دوال داخلية للمساعدتها لأن الدالة الداخلية لا تتشارك مع التابع في إمكانية الوصول الى الكائن لأن قيمة `this` الخاصة بها مرتبطة بقيمة خاطئة. لحسن الحظ هنالك حل بسيط، فإذا عَرَّفَ التابع متغيراً وأسند اليه قيمة `this` فعندها تستطيع الدالة الداخلية الوصول الى `this`الخاصة بالتابع من خلال ذاك المتغير. وقد أُؤتلف على تسمية ذالك المتغير ب`that`:

```javascript
// اضافة التابع method الى الكائن myObject.
myObject.double = function ( ) {
 var that = this; // الحل.
 var helper = function ( ) {
 that.value = add(that.value,that.value);
 };
 helper( ); // استدعاء الدالة helper.
};
// استدعاء double كتابع.
myObject.double( );
document.writeln(myObject.value); //6
```

### نمط استدعاء الباني

الجافا سكربت هي لغة وراثةٍ نماذجية. وذالك يعني أن الكائن يستطيع الوراثة مباشرةً من كائن آخر. حيث أن اللغة عديمة الأصناف(class-free).

وهذا مختلف جذرياً عن الوضع السائد حالياً. فمعظم اللغات اليوم تعتمد على الأصناف. الوراثة النماذجية معبرة بقوة، لكنها غير مفهومة على نطاق واسع والجافا سكربت نفسها غير واثقة من طبيعتها النماذجية، لذا فقد وفرت صيغة (syntax) لإنشاء الكائنات قريبةٌ من اللغات الصنفيّة. ووجد بعض المبرمجين القادمين من لغات صنفيّة أن الوراثة النماذجية مقبولة ولكن هذه الصيغة تشوش على طبيعة الجافا سكربت النماذجية.

اذا تم استدعاء دالة وسَبْقِها جملة `new`, عندها سيتم إنشاء كائن جديد برابط خفي يربطه الى قيمة نموذج تلك الدالة. وسوف تشير `this` الى ذلك الكائن.

السابقة `new` تغير أيضاً من سلوك جملة الإرجاع `return`. سوف نتطرق الى ذلك في الفصل القادم. 

```javascript
// أنشئ دالة بنائية تدعة Quo.
// حيث تنشئ كائن يملك خاصية باسم status.
var Quo = function (string) {
 this.status = string;
};
// اعطِ جميع النسخ من هذا الصنف تابع علني 
// يدعى get_status.
Quo.prototype.get_status = function ( ) {
 return this.status;
};
// أنشئ نسخة من Quo.
var myQuo = new Quo("confused");
document.writeln(myQuo.get_status( )); // confused
```

الدوال المخصصة للإستخدام مع السابقة `new` تدعى دوالاً بنائيّة. وقد أُصطلح على أن يبدأ اسمها بحرف كبير في الأبجدية الإنجليزية. وإذا تم مناداة الباني بدون `new`. عندها يمكن أن تحدث أُمورٌ سيئة جداً بدون أي تنبيهات في وقت الترجمة أو في وقت التشغيل. لذا فبدء الاسم بحرف كبير مهم جداً.

استخدام هذا الشكل من أشكال الباني ليس محبذاً. سوف نرى بدائل أفضل في الفصل القادم.

### نمط الاستدعاء باستخدام Apply

بما أن الجافا سكربت تعتبر لغة وظيفية كائنية التوجه، فيمكن لدوالها أن تمتلك توابع.

التابع `apply` يتيح لنا انشاء مصفوفة من الوسائط لاستخدامها في استدعاء الدالة، وكذلك تجعلنا نحدد قيمة `this` بأنفسنا. تأخذ الدالة `apply` معاملين. المعامل الأول هو القيمة التي سيتم إسنادها إلى `this`. والثاني هو مصفوفة من المعاملات. 

```javascript
// أنشئ مصفوفة من رقمين وقم بجمعهن.
var array = [3, 4];
var sum = add.apply(null, array); // المجموع يساوي 7
// أنشئ كائناً بخاصية status.
var statusObject = {
 status: 'A-OK'
};
// statusObject لم يرث من Quo.prototype,
// لكن يمكننا استدعاء التابع get_status 
// على الكائن statusObject على الرغم من أنه لا يمتلك هذا التابع
var status = Quo.prototype.get_status.apply(statusObject);
 // status تساوي 'A-OK
```

### الوسائط arguments

أحد المعاملات الإضافية التي تكون متاحة للدوال عند استدعائها هي المصفوفة `arguments`. حيث تتيح الوصول الى جميع المعاملات التي تم ارسالها الى الدالة عند استدعائها، بما في ذلك الوسائط الفائضة التي لم يقابلها معامل لتسند إليه. وذلك يجعل بالإمكان كتابة دوال تستطيع استيعاب عدد غير محدد من المعاملات:

```javascript
// أنشئ دالة تقوم بجمع الكثير من الأرقام.

// لاحظ أن تعريف المتعير sum داخل
// الدالة لا يتعارض مع المتغير sum الآخر
// المعرف خارج الدالة. حيث أن الدالة
// لا ترى إلا المتغير الداخلي
var sum = function ( ) {
 var i, sum = 0;
 for (i = 0; i < arguments.length; i += 1) {
 	sum += arguments[i];
 }
 return sum;
};
document.writeln(sum(4, 8, 15, 16, 23, 42)); // 108
```

هذا ليس نمطاً مفيداً بالتحديد. سوف نرى في الفصل السادس كيف نظيف تابعاً مشابهاً للمصفوفات. 

وبسبب خطئ في التصميم، `arguments` في الواقع ليست مصفوفة. إنما هي كائن شبيه بالمصفوفات. حيث تمتلك خاصية `length` لكنها لا تملك أيً من التوابع الخاصة بالمصفوفات. سوف نرى تبعات خطئ التصميم هذا في نهاية الفصل.

### الإرجاع

عندما تستدعى الدالة، يبدأ التنفيذ من الجملة الأُولى، وينتهي عندما يصل الى خاصرة الإغلاق `{` التي تُنهي جسم الدالة. وهذا يجعل الدالة ترجع التحكم الى جزء البرنامج الذي قام باستدعائها. 

الجملة  `return` يمكن أن تستخدم لجعل الدالة تقوم بالإرجاع مبكراً. وعندما تنفذ جملة `return`، تقوم الدالة بالإرجاع مباشرةً دون تنفيذ باقي الجمل. 

الدالة دائماً ترجع قيمة، فإذا لم تحدد قيمة الإرجاع، عندها يتم إرجاع `undefined`.

إذا تم استدعاء الدالة مع السابقة `new`  ولم تكن القيمة الراجعة كائناً. عندها يتم إرجاع الكائن الجديد بدلاً من القيمة المحددة. 

### الاستثناءات (Exaptions)

تقدم الجافا سكربت آلية لمعالجة الاستثناءات، الاستثناءات هي حوادث غير اعتيادية-لكنها ليست غيرة متوقعة ابداً- تعترض المسار الطبيعي للبرنامج. عندما يتم الكشف عن مثل هذه الحوادث. يجب على برنامجك أن يرمي استثناءً:

```javascript
var add = function (a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw {
            name: 'TypeError',
            message: 'هذه الدالة تتطلب أرقاماً'
        };
    }
    return a + b;
}
```

 الجملة `throw` تقوم بقطع تنفيذ الدالة. ويجب ان يتبعها كائن استثناء يحتوي على خاصية `name` والتي تحدد نوع الاستثناء، وخاصية `message` والتي تصف الاستثناء. ويمكنك أيضاً إضافة أي خواصٍ أُخرى.

سيتم ارسال كائن الاستثناء الى البند `catch` الخاص بالجملة `try`:

```javascript
// أنشئ دالة try_it function التي تستدعي دالة add الجديدة
// بطرقية غير صحيحة.
var try_it = function ( ) {
     try {
    	 add("seven");
     } catch (e) {
     	document.writeln(e.name + ': ' + e.message);
     }
}
try_it( );
```

اذا تم رمي استثناء في كتلة الجملة `try` فسيتنقل التحكم الى البند `catch`.

الجملة `try` تمتلك بند `catch` واحدٍ فقط، والذي يستقبل جميع الاستثناءات، فإذا كانت معالجة الاستثناء تعتمد على نوعه، عندها يجب على معالج الاستثناء أن يقوم بفحص الخاصية `name` ليحدد نوع الاستثناء ويقوم بمعالجته.

### الأنواع المعززة

تسمح الجافا سكربت بتعزيز الأنواع الأساسية الخاصة بها حيث رأينا في الفصل الثالث كيف أنَّ إضافة تابع جديد لـ `Object.prototype` يجعل هذا التابع متوفراً لجميع الكائنات. هذا أيضاً ينطبق على الدوال والأرقام والسلاسل النصية والتعابير النمطية وايضاً على القيم البوليانيّة.

فعلى سبيل المثال، من خلا تعزيز `Function.prototype نستطيع أن نضيف تابع لجميع الدوال:

```javascript
Function.prototype.method = function (name, func) {
 this.prototype[name] = func;
 return this;
};
```

من خلال تعزيز الـ `Function.prototype` بالتابع `method`، لم نعد بحاجة الى كتابة اسم كلمة prototype لإضافة تابع جديد. وهذه سلبية تم إخفائها.

الجافا سكربت لا تمتلك نوعاً خاصاً بالأرقام الصحيحة، لذا يتوجب علينا في بعض الأحيان إزالة الجزء العشري من الرقم للتعامل بالأرقام الصحيحة. والطرقية التي توفرها الجافا سكربت لذالك ليست سلسة. نستطيع إصلاح ذلك بإضافة تابع الى `Number.prototype` ليقوم بذلك العمل. حيث سيستخدم إما `Math.ceil` أو `Math.floor` حسب اشارة الرقم:

```javascript
Number.method('integer', function ( ) {
 return Math[this < 0 ? 'ceil' : 'floor'](this);
});
document.writeln((-10 / 3).integer( )); // -3
```

تفتقر الجافا سكربت الى وجود تابع يقوم بحذف المسافات الزائدة في نهاية السلاسل النصيّة. هذا حل بسيط لتلك المشكلة:

```javascript
String.method('trim', function ( ) {
 return this.replace(/^\s+|\s+$/g, '');
});
document.writeln('"' + " أنيق ".trim( ) + '"');
```

يستخدم التابع `trim` التعابير النمطية لحل المشكلة. سوف نرى المزيد عنها في الفصل السابع.

يمكننا تقديم تحسينات كبيرة للغة من خلال تعزيز أنواعها. وهذا التعزيز ممكن بفضل الطبيعة الديناميكية للوراثة النماذجية. فجميع القيم تحصل مباشرةً على التوابع الجديدة حتى لو كانت هذه القيم قد أٌنشئت قبل التعزيز.

وبما أن نماذج الأنواع الأساسية عامة، فيجب أخذ الحيطة والحذر عند التعامل مع مكتبات كثيرة لتجنب التعارض بينها. وأحد طرق الدفاعية لذلك هي بالتأكد من عدم وجود التابع قبل إضافته:

```javascript
// أضف التابع وفق شروط.
Function.prototype.method = function (name, func) {
 	if (!this.prototype[name]) {
         this.prototype[name] = func;
         return this;
	 }
};
```

وهناك نقطة أُخرى أيضاً، فجملة for in تتعامل بشكل سيئ مع الخصائص. وقد رأينا بعض الطرق لتفادي هذه المشكلة في الفصل الثالث: حيث يمكننا استخدام التابع `hasOwnProperety` لاستبعاد الخصائص الموروثة، ويمكننا أيضاً قصر البحث على أنواع محددة فقط.

### التعاود

الدالة التعاوديّة هي دالة تنادي نفسها بشكل مباشر أو غير مباشر، التعاود هي تقنية برمجية قوية حيث تقوم بتقسيم المشكلة الى عدة مشاكل أصغر، كل منها يمكن حله بشكل بسيط ومباشر. بشكل عام الدالة التعاودّية تنادي نفسها لحل مشاكلها الجزئية. 

برج هانوي هي أُحجية شهيرة، حيث تحتوي على ثلاثة قضبان ومجموعة من الأقراص بأحجام مختلفة مثقوبة من المنتصف. تبدأ الأُحجية بكون جميع الأقراص مكومة في قضيب البداية حيث يوضع القرص الأصغر فوق القرص الأكبر منه. والهدف هو تحريك الكومة من قضيب البداية الى قضيب النهاية قرصاً قرصاً. بشرط أن لا يوضع قرص فوق قرص أصغر منه. وهذه الأحجية لها حل تعاوديٌ بسيط:

```javascript
var hanoi = function hanoi(disc, src, aux, dst) {
     if (disc > 0) {
         hanoi(disc - 1, src, dst, aux);
         document.writeln('حرك القرص ' + disc +
      			  ' من ' + src + ' الى ' + dst);
         hanoi(disc - 1, aux, src, dst);
     }
};

hanoi(3, 'النهاية', 'المساعد', 'البداية');
```

حيث يعطينى الحل لتحريك 3 أقراص:

```pseudocode
حرك القرص 1 من البداية الى النهاية
حرك القرص 2 من البداية الى المساعد
حرك القرص 1 من النهاية الى المساعد
حرك القرص 3 من البداية الى النهاية
حرك القرص 1 من المساعد الى البداية
حرك القرص 2 من المساعد الى النهاية
حرك القرص 1 من البداية الى النهاية
```

تقوم الدالة `hanoi` بتحريك كومة الأقراص من قضيب الى آخر بستخدام القضيب المساعد إذا احتاجت الى ذلك، حيث تقوم بتجزئة المشكلة الى ثلاث مشاكل جزئية، أولاً تقوم بإخراج القرص الأخير  من خلال تحريك باقي الأقراص فوقه الى القضيب المساعد، ثم يمكنها تحريكه الى قضيب النهاية. وبعد ذلك  تقوم بتحريك باقي الأقراص الى قضيب النهاية من خلال إعادة تنفيذ ما سبق بواسطة مناداتها لنفسها.

يمرر للدالة `hanoi` رقم القرص الذي ستحركه وأسماء القضبان الثلاثة التي ستستخدمها. وعندما تنادي نفسها، تقوم بالتعامل مع القرص التالي والذي كان فوق القرص الحالي. وفي لحظة ما سوف تنادى برقم قرص غير موجود "0" وعندها لن تفعل شيئاً، وعدم فعل شيئٍ في هذه الحالة يجعلنا واثقين من أن هذه الدالة لن تستمر بمناداة نفسها الى الأبد.

يمكن أن تكون الدوال التعاوديّة فعّالة جداً في التعامل مع التشجيرات مثل نموذج كائن المستَند( Document Object Model) أو اختصاراً الـ DOM الخاص بالمتصفحات. حيث يعطى كل نداءٍ تعاودي مهمة التعامل مع جزء صغير من التشجير للعمل عليه:

```javascript
// عرف دالة walk_the_DOM التي تزور جميع
// عقد التشجير بنفس ترتيب الHTML لها, حيث تبدأ
// from some given node. It invokes a function,
// passing it each node in turn. walk_the_DOM calls
// itself to process each of the child nodes.
var walk_the_DOM = function walk(node, func) {
     func(node);
     node = node.firstChild;
     while (node) {
         walk(node, func);
         node = node.nextSibling;
     }
};
// Define a getElementsByAttribute function. It
// takes an attribute name string and an optional
// matching value. It calls walk_the_DOM, passing it a
// function that looks for an attribute name in the
// node. The matching nodes are accumulated in a
// results array.
var getElementsByAttribute = function (att, value) {
     var results = [];
     walk_the_DOM(document.body, function (node) {
         var actual = node.nodeType === 1 && node.getAttribute(att);
         if (typeof actual === 'string' &&
         (actual === value || typeof value !== 'string')) {
            results.push(node);
         }
     });
     return results;
};
```

بعض اللغات توفر تحسين يدعى ذيل التعاود. ذلك يعني إذا كانت الدالة ترجع فقط ناتج استدعائها لنفسها، عندها سيتم تبديل الاستدعاء التعاودي بحلقة تكرارية، وهذا يسرع العملية جداً. مع الأسف، حالياً لا توفر الجافا سكربت هذا التحسين. ولهذا فإن دوال التي تعاود نفسها كثيراً جداً يمكن أن يفشل تنفيذها بسبب اجهاد مكدس الاستدعاء (Callback stack):

```javascript
// Make a factorial function with tail
// recursion. It is tail recursive because
// it returns the result of calling itself.
// JavaScript does not currently optimize this form.
var factorial = function factorial(i, a) {
     a = a || 1;
     if (i < 2) 
     	return a;
     }	
     return factorial(i - 1, a * i);
 };
document.writeln(factorial(4)); // 24
```

### النطاق

في لغات البرمجة يتحكم النطاق بمرئية المتغيرات والمعاملات ومدّة حياتها. وهذا أمر بالغ الأهمية في لغات البرمجة لأنه يقلل من تعارض الأسماء ويقدم إدارة آلية للذاكرة:

```javascript
var foo = function ( ) {
    var a = 3, b = 5;
    var bar = function ( ) {
        var b = 7, c = 11;
        // At this point, a is 3, b is 7, and c is 11
        a += b + c;
        // At this point, a is 21, b is 7, and c is 11
    };
   // At this point, a is 3, b is 5, and c is not defined
    bar( );
   // At this point, a is 21, b is 5
};
```

أغلب اللغات التي تمتلك صيغة سي (C syntax) لديها نطاق كُتَلّي. فجميع المتغيرات المُعَرّفة في كتلة -مجموعة من الجمل بين خاصرتين- غير مرئية من خارج الكتلة. والمتغير المُعرَف في كتلة يمكن أن يُحذَف عند انتهاء تنفيذ تلك الكتلة. وهذا أمر جيد.

لكن ومع الأسف، الجافا سكربت لا تمتلك نطاق كُتَلّي مع أن صيغتها تقترح ذلك. وهذا اللُبس يمكن أن يكون مصدراً للأخطاء.

الجافا سكربت تمتلك نطاق دالّي. وذلك يعني أن المتغيرات والمعاملات المُعَرّفة في دالة لا تكون مرئية من خارجها، وأن المتغير المٌعَرَّف في أي مكان في الدالة مرئي من أي مكان في الدالة.

في كثير من اللغات الحديثة، يوصى بتأخير تعريف المتغيرات قدر الإمكان حتى يتم استخدامها، لكن هذه النصيحة تغدو سيئةً في الجافا سكربت لأنها لا تملك نطاق كُتَلّي. لذا عوضاً عن ذلك، ينصح بتعريف جميع المتغيرات المستخدمة في دالة ما في بدايتها.

### المُغلِف

البشرى في ما يتعلق بالنطاق أن الدّوال الداخلية يمكنها أن تصل الى المتغيرات والمعاملات الخاصة بالدّالة التي عُرّفِت داخلها باستثناء `this` و `arguments`. وهذا أمرٌ سارٌ جداً.

الدالة `getElementsByAttribute` عملت بشكل صحيح، وذلك لأنها عَرَّفت المتغير `result`، والدالة الداخلية التي مُرِّرَت الى `walk_the_DOM` تستطيع وصولٌ الى ذاك المتغير.

والحالة المثيرة للاهتمام هي اتنتهي صلاحية الدالة الداخلية قبل الدالة الخارجية.

سابقاً قمنا بإنشاء الكائن `myObject` الذي يملك الخاصية `value` والتابع `increment`. افرض أننا نريد حماية الخاصية `value` من التعديلات المباشرة.

بدلاً من انشاء الكائن باستخدام الكائن الحرفي، سنقوم بعمل دالة تقوم بإرجاع كائن حرفي. تلك الدالة تُعَرِّفُ متغيراً باسم `value` حيث يكون مرئياً دائماً للتابعين `getValue` و`increment`، لكنه سيبقى غير مرئي لباقي البرنامج بسبب النطاق الدّالي:

```javascript
var myObject = (function ( ) {
     var value = 0;
     return {
     	increment: function (inc) {
        	 value += typeof inc === 'number' ? inc : 1;
         },
     	getValue: function ( ) {
            return value;
         }
     };
}( ));
```

نحن هنا لم نقم بإسناد دالة الى `myObject`، بل قمنا بإسناد ما يرجعه استدعاء الدالة اليه. لاحظ العامل`()` في السطر الأخير. الدالة ترجع كائناً يحوي على تابعين، وهذين التابعين يتمتعان بميزة الوصول الى المتغير `value`.

الباني `Quo` الذي أنشأناه في بداية الفصل يبني كائن يملك الخاصية `ststus` والتابع `get_status`. لكن ذلك لا يبدو مهماً. لماذا نستدعي جالباً(getter method) لنصل الى خاصية يمكننا الوصول اليها مباشرةً؟ من الأجدى أن تكون الخاصية سرية(private). لذا دعنا نُعَرِف شكل آخر للباني حتى نقوم بذلك: 

```javascript
// Create a maker function called quo. It makes an
// object with a get_status method and a private
// status property.
var quo = function (status) {
     return {
         get_status: function ( ) {
        	 return status;
    	 }
     };
};
// Make an instance of quo.
var myQuo = quo("amazed");
document.writeln(myQuo.get_status( ));

```

صممت الدالة `quo` لتستخدم بدون السابقة `new`. لذا فلم يبدأ اسمها بحرف كبير. عندما ننادي الدالة `quo`، تُرجع لنا كائناً يحوي على التابع `get_status`. وقد خُزن مَرجعٌ الى ذاك الكائن في `myQuo`. وحتى بعد ارجاع الكائن، يبقى لدى التابع `get_status` ميزة الوصول الى المعامل `status` الخاص بـ `quo`. التابع `get_status` لا يملك ميزة وصولٍ الى نسخةٍ من المعامل، إنما لديه وصولُ الى المعامل نفسه. وهذا ممكن بسبب أن الدالة لديها وصولُ الى السياق(context) الذي عٌرِّفت فيه. وهذا ما يدعى بالمُغلف.

دعنا نأخذ مثالاً أكثر فائدة:

```javascript
// Define a function that sets a DOM node's color
// to yellow and then fades it to white.
var fade = function (node) {
     var level = 1;
     var step = function ( ) {
         var hex = level.toString(16);
         node.style.backgroundColor = '#FFFF' + hex + hex;
         if (level < 15) {
             level += 1;
             setTimeout(step, 100);
         }
     };
     setTimeout(step, 100);
};
fade(document.body);
```

قمنا بمناداة الدالة `fade` ومررنا اليها `document.body` وهي عقدة(node) أُنشئت بواسطة الوسم `<body>`. الدالة `fed` أسندت قيمة 1 الى المتغير `level` ثم عَرَّفت الدالة `step`. ثم نادت `setTimeout` ومررت اليها الدالة `step` ومقدار وقت ب 100 جزء من ثانية. ثم قامت بالإرجاع، أي انتهت.

فجأةً وبعد مرور عٌشرٍ من الثانية، تم استدعاء الدالة `step`. والتي تقوم بإنشاء محرف بأساس 16 -أي بنظام عد سِتَّ عَشري- بالاعتماد على المتغير `level` الخاص بالدالة `fade`. ثم تقوم بتعديل لون الخلفية `backgroundColor` الخاص بالمعامل `node`. ثم تفحص المتغير `level`، فإذا لم يصل الى اللون الأبيض بعد، تقوم بزيادته ثم تعيد استخدام `setTimeout` لجدولة جولة أٌخرى بعد 100 جزء من الثانية.

فجأةً، تم استدعاء الدالة `stpe` مرة أٌخرى، لكن هذه المرة، قيمة المتغير `level` تساوي 2. على الرغم من أن تنفيذ الدالة `fade` انتهى منذ فترة، إلا أنه تم الإبقاء على متغيراتها ولم تحذف طالما أن هناك دالة داخلية أو أكثر لا زالت تحتاجها.

إنه لمن المهم فهم أن الدوال الداخلية لديها وصولٌ الى متغيرات الدالة الخارجية بذاتها وليس الى نسخة منها لتجنب الوقع في المشكلة التالية:

```javascript
// أنشئ دالة تقوم باسناد معالجات أحداث لمصفوفة من العقد بطريقة خاطئة.
// عندما تضغط على عقدمة ما، يجب أن يظهر رقم ترتيب العقدة في صندوق تنبيه.
//  لكن بدلاً من ذلك، هنا سيتم دائماً إظهار عدد العقد
var add_the_handlers = function (nodes) {
     var i;
     for (i = 0; i < nodes.length; i += 1) {
         nodes[i].onclick = function (e) {
         	alert(i);
         };
     }
};
```

كان من المفترض على الدالة `add_the_handlers` أن تعطي كل معالجٍ رقماً مميزاً. لكنها فشلت، لأن الدوال المعالجة مرتبطة بالمتغير `i` وليس قيمة المتغير `i` عندما تم إنشاء الدالة، أي ليست مرتبطة بنسخة منه وإنما به نفسه.

```javascript
// أنشئ دالة تقوم باسناد معالجات أحداث لمصفوفة من العقد بطريقة صحيحة.
// عندما تضغط على عقدة ما، سيتم إظهار ترتيب العقدة في صندوق تنبيه
var add_the_handlers = function (nodes) {
     var helper = function (i) {
         return function (e) {
         	alert(i);
         };
     };
     var i;
     for (i = 0; i < nodes.length; i += 1) {
 	   	 nodes[i].onclick = helper(i);
	 }
};
```

تجنبنا إنشاء الدوال داخل حلقة التكرار لأن ذلك يمكن أن يكون سيئاً وأيضاً يمكن أن يؤدي إلى لُبس كما رأينا في المثال السابق. فتجنبنا ذلك اللُبس بعمل دالة مساعدة خارج الحلقة التكرارية والتي ستقوم بإعطائنا دوالاً معالجة ملتزمة مع القيمة الحالية للمتغير `i`.

### كولباك

تستطيع الدوال جعل التعامل مع الأحداث غير المتصلة أسهل، على سبيل المثال، افرض أن هناك سلسلة من الأحداث تبدأ بتفاعل المستخدم ثم إرسال طلبٍ الى الخادم ثم عرض رد الخادم. الطريقة البسيطة لعمل ذلك هي:

```javascript
request = prepare_the_request( );
response = send_request_synchronously(request);
display(response);
```

المشكلة في هذا الأُسلوب هي أن إرسال طلب متزامن(Synchronous) عبر الشبكة سيجعل العميل في حالة جمود حتى يرجع الرد، وإذا كانت الشبكة أو الخادم بطيئين، ستكون جودة الاستجابة أبداً غير مقبولة. 

إرسال طلب غير متزامن سيكون أُسلوباً أفضل، وذلك باستعمال دالة كولباك والتي سيتم استدعائها عندما يتم استلام رد الخادم، والدالة المتزامنة تقوم بالإرجاع مباشرةً، لذا لن يتجميد العميل:

```javascript
request = prepare_the_request( );
send_request_asynchronously(request, function (response) {
	display(response);
});
```

قمنا بتمرير الدالة كمعامل الى الدالة `send_request_asynchronously` حيث سيتم استدعاء المعامل عندما يكون الرد جاهزاً.

### الوحدة

يمكن أن نستخدم الدوال كمغلفات لنصنع وحدات. والوحدة هي كائن أو دالة تقدم واجهة(interface) تخفي حالتها - أي حالة الدالة أو الكائن- وطريقة كتابتها. وباستخدامنا لدوال في إنشاء الوحدات، نستطيع إنهاء استخدامنا للمتغيرات العامة بشكل كاملٍ تقريباً، وبذلك نخفف من أثر أحد أسوء المزايا في الجافا سكربت.

على سبيل المثال، افرض أننا نريد تعزيز الـ `String` بتابع يدعى `deentityify`. وعمله هو البحث عن كيانات (entity)HTML في سلسلة نصيّة واستبدالها بما يساويها. من من المنطقي أن يتم حفظ أسماء الكيانات وما يساويها في كائن ما. لكن أين يجب أن نحفظ ذلك الكائن؟ يمكننا وضعه في متغير عام. لكن المتغيرات العامة ليست شيئاً جيداً. اذاً يمكننا أن نعرفه داخل التابع نفسه، لكن ذلك يزيد من كلفة التشغيل (runtime cost) لأن ذاك الكائن سيتم إعادة إنشائه في كل مرة يتم فيها استدعاء الدالة. الأُسلوب الأمثل هو بوضعه في مغلف، وربما أيضاً نوفر تابع إضافياً يمكنه إضافة كيانات جديدة:

```javascript
String.method('deentityify', function ( ) {
    // The entity table. It maps entity names to
    // characters.
     var entity = {
         quot: '"',
         lt: '<',
         gt: '>'
     };
    // Return the deentityify method.
     return function ( ) {
        // This is the deentityify method. It calls the string
        // replace method, looking for substrings that start
        // with '&' and end with ';'. If the characters in
        // between are in the entity table, then replace the
        // entity with the character from the table. It uses
        // a regular expression (Chapter 7).
         return this.replace(/&([^&;]+);/g,
             function (a, b) {
                 var r = entity[b];
                 return typeof r === 'string' ? r : a;
             }
         );
     };
}());
```

لاحظ أننا في السطر الأخير قما باستدعاء الدالة مباشرةً باستخدام العامل `()`، حيث أن ذاك الاستدعاء أنشئ وأرجع دالةً، والتي أصبحت التابع  `deentityify`.

```javascript
document.writeln('&lt;&quot;&gt;'.deentityify( ));  // <">
```

نمط الوحدات هذا يستفيد من نطاق الدالة والمغلف لإنشاء علاقات خاصة وملتزمة. 

النمط العام للوحدات هو دالة تعرف متغيرات ودوال أُخرى خاصة، تنشئ دوال تمتاز بوصول الى تلك المتغيرات والدوال الخاصة، ثم ترجع تلك الدوال أو تجعلها متوفرة بطريقة ما. 

استخدام نمط الوحدات يمكن أن ينهي الاعتماد على المتغيرات العامة. فهي تعزز إخفاء المعلومات(information hiding) وممارسات تصميمة جيدة أُخرى. وهي فعالة جداً في كبسلة -من كلمة كبسولة- التطبيقات. 

وتستخدم الوحدات أيضاً لإنشاء كائنات مؤمنة، فدعنا نفرض أننا نريد إنشاء كائن ينتج لنا رقم تسلسلي:

```javascript
var serial_maker = function ( ) {
    // Produce an object that produces unique strings. A
    // unique string is made up of two parts: a prefix
    // and a sequence number. The object comes with
    // methods for setting the prefix and sequence
    42 | Chapter 4: Functions
    // number, and a gensym method that produces unique
    // strings.
     var prefix = '';
     var seq = 0;
     return {
         set_prefix: function (p) {
            prefix = String(p);
         },
         set_seq: function (s) {
            seq = s;
         },
         gensym: function ( ) {
             var result = prefix + seq;
             seq += 1;
             return result;
         }
     };
};
var seqer = serial_maker( );
seqer.set_prefix('Q');
seqer.set_seq(1000);
var unique = seqer.gensym( ); // unique is "Q1000"
```

الدالة هنا لا تستخدم `this` أو `that`. ونتيجة لذلك، ليس هناك طريقة لكمبرمايز الـ `seqer`. فليس هناك طريقة للحصول على الـ `prefix` أو الـ`seq`  أو التعديل عليهما إلا بالكيفية التي تحددها التوابع. الكائن `seqer` قابل للتعديل وذلك يعني أنه يمكن استبدال توابعه، لكن حتى هذا لا يمكننا من الوصول الى اسراره. ببساطة `seqer` هو مجموعة من الدوال، وهذه الدوال عبارة عن قدرات توفر صلاحيات محددة لاستخدام أو لتعديل الحالة السرية.

إذا مررنا `seqer.gensym` إلى دالة أُخرى فقد تستطيع تلك الدالة توليد سلسلة نصية فريدة، لكنها لن تتمكن من تعديل الـ `prefix` أو الـ `seq`.

### التتابع

بعض التوابع لا تملك قيماً راجعة. فعلى سبيل المثال، من الطبيعي أن لا ترجع التوابع التي تقوم بإسناد أو تعديل حالة الكائن أي شيء. ولكن إذا جعلنا هذه التوابع ترجع `this` بدلاً من `undefnied`،  عندها يمكننا تكوين التتابع. في التتابع، نستطيع استدعاء الكثير من توابع كائن ما بشكل متتابع في جملة واحدة:

```javascript
getElement('myBoxDiv')
 .move(350, 150)
 .width(100)
 .height(100)
 .color('red')
 .border('10px outset')
 .padding('4px')
 .appendText("Please stand by")
 .on('mousedown', function (m) {
 this.startDrag(m, this.getNinth(m));
 })
 .on('mousemove', 'drag')
 .on('mouseup', 'stopDrag')
 .later(2000, function ( ) {
 this
 .color('yellow')
 .setHTML("What hath God wraught?")
 .slide(400, 40, 200, 200);
 })
 .tip("This box is resizeable.");
```

في هذا المثال، الدالة `getElement` أرجعت لنا كائناً يعطي لعنصر الدوم (DOM) الذي يملك المُعَرِّف `"myBoxDiv"`  مجموعة من الوظائف. التوابع تسمح لنا بتحريك العنصر، تغير أبعاده وتنسيقه، ويضيف له سلوكاً. كل تابع منها يرجع الكائن، لذا يمكن استخدام ناتج الاستدعاء للقيام بالاستدعاء التالي.

التتابع يعطينا واجه معبرة جداً. ويمكنها أن تكبح جماح الواجهات التي تحاول فعل الكثير دفعة واحدة.

### التَكْريةَ (Curry)

الدوال قيم، وباستطاعتنا التلاعب بهذه القيم بأساليب مميزة. تتيح لنا التَكرِية إنشاء دالة جديدة من خلال دمج دالة ووسيطة: 

```javascript
var add1 = add.curry(1);
document.writeln(add1(6)); // 7
```

`add1` هي دالة أُنشِأت بواسطة تمرير الرقم 1 الى التابع `curry` الخاص بـ `add`. الدالة `add1` تضيف 1 الى وسيطتها. لا تمتلك الجافا سكربت تابعاً يسمى `curry`، لكن يمكننا معالجة ذلك بتعزيز الـ `Function.prototype`:

```javascript
Function.method('curry', function ( ) {
    var args = arguments, that = this;
    return function ( ) {
        return that.apply(null, args.concat(arguments));
    };
}); // Something isn't right...
```

يعمل التابع `curry` من خلال انشاء مُغلف يحيط بالدالة الأصلية ووسائطها. ثم يرجع دالةً أُخرى،  تقوم هذه الأخيرة عند استدعائها بتنفيذ الدالة الأصلية وإرجاع ناتجها، مُمَرِّرَةً اليها جميع الوسائط التي أُرسلت عند الاستدعاء الحالي بالإضافة الى الوسائط التي أُرسلت عند استدعاء التابع `curry`. حيث تم استخدام التابع `concat` الخاص بالمصفوفات لربط مصفوفتي الوسائط ببعضهما.  

مع الأسف، كما رأينا سابقاً، `arguments` ليست مصفوفةً فعلاً، لذا هي لا تملك التابع `concat`. وللتغلب على ذلك سنستخدم التابع `Array.slice` على مصفوفتي الـ `arguments`، وذلك سيرجع لنا مصفوفات حقيقية تمتلك التابع `contact`:

```javascript
Function.method('curry', function ( ) {
    var slice = Array.prototype.slice,
    args = slice.apply(arguments),
    that = this;
    return function ( ) {
    	return that.apply(null, args.concat(slice.apply(arguments)));
    };
})
```

### التحفيظ (Memoization)

يمكن للدوال استخدام الكائنات أو المصفوفات لتذكر ناتج حساباتها السابقة، مما يجعل من الممكن تجنب القيام بالأعمال غير الضرورية. وهذا التحسين يدعى بالتحفيض. 

دعنا نقل أننا نريد دالة عوديّة لحساب متتالية فيبوناتشي، الحد في متتالية فيبوناتشي يساوي مجموع الحدين السابقين له. وأول حدين هما 1 و 0:

```javascript
var fibonacci = function (n) {
	return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
};
for (var i = 0; i <= 10; i += 1) {
	document.writeln('// ' + i + ': ' + fibonacci(i));
}
// 0: 0
// 1: 1
// 2: 1
// 3: 2
// 4: 3
// 5: 5
// 6: 8
// 7: 13
// 8: 21
// 9: 34
// 10: 55
```

هذه الدالة تعمل، لكنها تقوم بالكثير من العمل غير الضروري. فقد تم استدعائها 453 مرة. حيث قمنا نحن باستدعائها 11 مرة، وهي قامت باستدعاء نفسها 442 مرة خلال قيامها بحساب قيم قامت غالباً بحسابها سابقاً. لكن إذا قمنا بتحفيظ الدالة، سنتمكن من تقليل عبء العمل عنها بشكل كبير.

سنقوم بحفظ النتائج في مصفوفة تدعى `memo` -أي من كلمة memory وتعني ذاكرة- ونخبئها في مغلف. وعندما يتم استدعاء الدالة، سنقوم أولاً بالتأكد فيما اذا كنا نعرف الناتج مسبقاً. فان كان كذلك، نقوم بإرجاع الناتج مباشرة:

```javascript
var fibonacci = (function ( ) {
     var memo = [0, 1];
     var fib = function (n) {
        var result = memo[n];
        if (typeof result !== 'number') {
            result = fib(n - 1) + fib(n - 2);
            memo[n] = result;
        }
        return result;
    };
    return fib;
}( ));
```

ترجع لنا هذه الدالة نفس النتائج، لكن تم استدعائها فقط 29 مرة. حيث قمنا نحن باستدعائها 11 مرة، وقامت هي باستدعاء نفسها 18 مرة أثناء استرجاعها للنتائج التي حفظتها. 

نستطيع تعميم هذا الأُسلوب من خلال انشاء دالة تساعدنا في انشاء دوَّالٍ تحفيظيّة. تأخذ الدالة `memorizer` -ومعناه المُحَفِّظ - مصفوفة `memo` مبدئيّة ودالة تمثل معادلةً تدعى`formula`. وتُرجع دالة عوديّة تدير عملية الحفظ واستدعاء دالة المعادلة عند الحاجة. ونقوم بتمرير الدالة العودية ووسائطها الى دالة المعادلة:

```javascript
var memoizer = function (memo, formula) {
    var recur = function (n) {
        var result = memo[n];
        if (typeof result !== 'number') {
            result = formula(recur, n);
            memo[n] = result;
        }
        return result;
    };
    return recur;
};
```

يمكننا الآن تعريف `fibonacci` باستخدام المُحَفِّظ `memoizer`:

```javascript
var fibonacci = memoizer([0, 1], function (recur, n) {
	return recur(n - 1) + recur(n - 2);
});
```

بابتكارنا دالة تنتج لنا دالة أُخرى، يمكننا أن نقلل بشكل كبير كمية العمل الذي يجب علينا القيام به. على سبيل المثال، لعمل دالة حفظيّة تحساب المضروب، لا نحتاج سوى توفير معادلة المضروب الأساسية:

```javascript
var factorial = memoizer([1, 1], function (recur, n) {
	return n * recur(n - 1);
});
```

