#### الفصل الرابع

# الدوال



أفضل شيئ في الجافا سكربت هو تطبيقها للدوال. لقد فعلت كل شيئ تقريباً بشكل صحيح. لكن، كما يمكن أن تتوقع من الجافا سكربت، فهي لم تفعل كل شيئ تمام بشكل صحيح.

الدالة تشتمل على مجموعة من الجمل. وهي الوحد e fundamental modular unit of JavaScript. فهي تستخدم لإخفاء المعلموات وإعادة استخدام الشيفرة والتكوين(composition). تستخدم الدوال لتحديد سلوك الكائنات. بشكل عام، صنعة البرمجة هي تحويل مجموعة من المتطلبات الى مجموعة من الدوال وهياكل البيانات. 

### كائنات الدوال

الدوال هي كائنات في الجافا سكربت، والكائان هو تجميعة من زوجي "اسم/قيمة" يمتلك رابطاً خفياً الى كائن نماذجي(prototype object). الكائنات الناشئة من كائن حرفي مرتبطة ب `Object.prototype`. أما كائنات الدوال فمرتبطة ب `Function.prototype` والذي هو بدووره مرتبطٌ ب `Object.prototype`. كل الدوال تمتلك خاصيتين إضافيتين تنشئان معها: سياق الدالة(context) والشيفرة التي تطبق سلوك الدالة.

جميع كائنات الدوال تمتلك خاصية `prototype` تنشأ معها. قيمتها عبارة عن كائن يحوي خاصية تسمى `constructor` -أي الباني من كلمة بناء- والذي هو قيمته الدالة نفسها. وهذا مختلف عن الرابك المخفي ل `Function.prototype`. المعنى الشائك لهذا الباني سيتم شرحه في الفصل القادم.

بما أن الدوال هي كائنات، فيمكن معاملتها مثل أي قيمة أٌخرى. الدوال يمكن تخزينها في المتغيرات والمصفوفات والكائنات. الدوال يمكن تمريرها كوسائط لدوالٍ أٌخرى. وأيضاً، بما أن الدوال هي في الأصل كائنات، فيمكنها أن تمتلك توابع. والأمر المميز في الدوال هو إمكانية استدعائها.



### الدالة الحرفيّة

كائنات الدوال تنشئ بواسطة الدوال الحرفية:

```javascript
// أنشء متغاً باسم add وخزن به دالة
// تقوم بجمع رقمين
var add = function (a, b) {
 return a + b;
};
```

الدالة الحرفية تمتلك أربعة أجزاء. الجزء الأول هو الكلمة المحجوزة `function`. 

الجزء الثاني اختياري، وهو اسم الدالة. ومكن للدالة استخدامُ ذلك الاسم لمناداة نفسها عَوْدياً(recursively). ويستخدم الاسم أيضاً بواسطة المصححات(debugger) وأدوات التطوير(development tools) للتعرف على الدالة. إذا لم يعطى للدالة اسم كما في المثال السابق، فعندها تسمى دالة مجهولة(anonymous).

الجزء الثالث هو مجموعة الوسائط الخاصة بالدالة، محاطة بأقواس ويفصل بينها بالفواصل. وهذه الوسائط سيتم تعريفها كمتغيرات في الدالة. وعلى عكس المتغيرات العادية التي يتم تهيئتها بقيمة `undefined` فإنها تهيَّأ بقيمة الوسائط المرسلة مع استدعاء الدالة.

الجزء الرابع هو مجموعة من الكلمات محاطة بحاصرتين، هذه الجمل هي جسم الدالة. حيث يتم تنفيذها عند استدعاء الدالة.

يمكن للدالة الحرفية أن تظهر في أي مكان تظهر فيه التعابير. وأيضاً يمكن تعريف الدوال داخل دالة أُخرى. بالطبع يكون لهذه الدالة وسائط ومتغيرات خاصة بها. وللدالة الداخلية القدرة على الوصول لوسائط ومتغيرات الدالة الخارجية أيضاً. يحتوي كائن الدالة المنشئ بواسطة الدالة الحرفية على رابط للسياق الخارجي(outer context). وهذا يدعى بالمغلف(closure) وهو مصدر لقوة هائلة. 

### الاستدعاء

استدعاء الدالة يعلق تنفيذ الدالة الحالية ويمرر التحكم والعوامل(parameters) للدالة الجديدة. بالإضافة الى العوامل المصرح بها، تستقبل كل الدوال عاملين إضافيين: `this` و`arguments`. العامل `this` مهم جداً في البرمجة كائنية التوجه، وقيمتها تحدد بنمط استدعائها. هناك أربع أنماط للاستدعاء في الجافا سكربت: نمط استدعاء التابع، نمط استدعاء الدالة، نمط استدعاء الباني، ونمط الاستدعاء باستخدام `apply`. تختلف الأنماط بكيفية تهيئة العامل الإضافي `this`.

عامل الاستدعاء هو عبارة عن زوجين من الأقواس تتبعان أي تعبير ينتج دالة. الأقواس أيضاً قد تحوي على صفر أو من التعابير تفصل بينها الفواصل. وكل تعبير ينتج قيمة وسيطة واحدة. وكل وسيطة سيتم إسنادها الى معامل واحد. ولا يلزم أن تكون عدد الوسائط مساوياً لعدد المعاملات. فإذا كان عدد الوسائط أكثر فسيتم تجاهل الوسائط الزائدة. أما إذا كان عددها أقل، فسيتم إعطاء المعاملات الباقية قيمة `undefined`. لا يتم تنفيذ تحقق من الأنواع على قيم الوسائط حيث أن أي نوع من القيم يمكن أن يرسل لأي معامل.

###  نمط استدعاء التابع

نسمي الدالة تابع إذا كانت جزءً من كائن، وعند استدعاء التابع تمثل الجملة `this` ذلك الكائن. إذا احتوى الاستدعاء على تنقيح- النقطة . أو الأقواس المعقوفة []- عندها يكون الإستدعاء كتابع.

```javascript
// Create myObject. It has a value and an increment
// method. The increment method takes an optional
// parameter. If the argument is not a number, then 1
// is used as the default.
var myObject = {
 value: 0,
 increment: function (inc) {
 this.value += typeof inc === 'number' ? inc : 1;
 }
};
myObject.increment( );
document.writeln(myObject.value); // 1
myObject.increment(2);
document.writeln(myObject.value); // 3
```

يستطيع التابع استخدام المتغير `this` للوصول الى الكائن واسترجاع القيم منه أو تعديلها، حيث يتم ربط `this` بالكائن خلال وقت الاستدعاء. وهذا الربط يجعل من الدوال التي تستخدم `this` قابلة لإعداة الاستخدام بدرجة عالية. التوابع التي تصل الى سياق كائنها من المتغير `this` تسمى توابع علنيّة(public methods).

### نمط استدعاء الدالة

عندما لا تكون الدالة خاصية في كائن ما، عندها تستدعا كدالة:

```javascript
var sum = add(3, 4); // sum يساوي 7	
```

عندما تستدعا الدالة بهذا النمط تربط المتغير `this` بالكائن العام. وهذا كان خطأ في تصميم اللغة. والصواب في حال استدعاء الدوال الداخلية-دالة داخل دالة أُخرى- أن تربط `this` الخاصة بها ب`this` الخاصة بالدالة الخارجية. وما ترتب على هذا الخطأ أن التوابع لا تستطيع توظيف دوال داخلية للمساعدة في عملها لأن الدالة الداخلية لا تتشارك مع التابع في إمكانية الوصول الى الكائن لأن قيمة `this` الخاصة بها مرتبطة بقيمة خاطئة. لحسن الحظ هنالك حل بسيط، فإذا عرف التابع متغيراً وأسند اليه قيمة `this` فعندها تستطيع الدالة الداخلية الوصول الى `this`الخاصة بالتابع من خلال ذاك المتغير. وقد أُؤتلف على تسمية ذالك المتغير ب`that`:

```javascript
// اضافة التابع method الى الكائن myObject.
myObject.double = function ( ) {
 var that = this; // الحل.
 var helper = function ( ) {
 that.value = add(that.value,that.value);
 };
 helper( ); // استدعاء الدالة helper.
};
// استدعاء double كتابع.
myObject.double( );
document.writeln(myObject.value); //6
```

### نمط استدعاء الباني

الجافا سكربت هي لغة وراثة نماذجية. وذالك يعني أن الكائن يستطيع الوراثة مباشرةً من كائن آخر. حيث أن اللغة عديمة الأصناف(class-free).

وهذا مختلف جذرياً عن الوضع السائد حالياً. فمعظم اللغات اليوم تعتمد على الأصناف. الوراثة النماذجية معبرة بقوة، لكنها غير مفهومة على نطاق واسع والجافا سكربت نفسها غير واثقة من طبيعتها النماذجية، لذا فقد وفر ت إملاءً(syntax) لإنشاء الكائنات قريبٌ من اللغات الصنفية. ووجد بعض المبرمجين القادمين من لغات صنفيّة أن الوراثة النماذجية مقبولة ولكن هذا الإملاء يشوش على طبيعة الجافا سكربت النماذجية.

اذا تم استدعاء دالة وسَبْقِها بجملة `new`, عندها سيتم إنشاء كائن جديد برابط خفي يربطه الى قيمة نموذج تلك الدالة. وسوف تشير `this` الى ذلك الكائن.

السابقة `new` تغير أيضاً من سلوك جملة الإرجاع `return`. سوف نتطرق الى ذلك في الفصل القادم. 

```javascript
// أنشئ دالة بنائية تدعة Quo.
// حيث تنشئ كائن يملك خاصية باسم status.
var Quo = function (string) {
 this.status = string;
};
// اعطِ جميع النسخ من هذا الصنف تابع علني 
// يدعى get_status.
Quo.prototype.get_status = function ( ) {
 return this.status;
};
// أنشئ نسخة من Quo.
var myQuo = new Quo("confused");
document.writeln(myQuo.get_status( )); // confused
```

الدوال المخصصة للإستخدام مع السابقة `new` تدعى دوالاً بنائيّة. وقد أُصطلح على أن يبدأ اسمها بحرف كبير في الأبجدية الإنجليزية. وإذا تم مناداة الباني بدون `new`. عندها يمكن أن تحدث أُمور سيئة جداً بدون أي تنبيهات في وقت الترجمة أو في وقت التشغيل. لذا فبدئ الاسم بحرف كبير مهم جداً.

استخدام هذا الشكل من أشكال الباني ليس محبذاً. سوف نرى بدائل أفضل في الفصل القادم.

### نمط الاستدعاء باستخدام Apply

بما أن الجافا سكربت تعتبر لغة وظيفية كائنية التوجه، فيمكن لدوالها أن تمتلك توابع.

التابع `apply` يتيح لنا انشاء مصفوفة من الوسائط لاستخدامها في استدعاء الدالة، وكذلك تجعلنا نحدد قيمة `this` بأنفسنا. تأخذ الدالة `apply` معاملين. المعامل الأول هو قيمة التي سيتم اسنادها إلى `this`. والثاني هو مصفوفة من المعاملات. 

```javascript
// أنشئ مصفوفة من رقمين وقم بجمعهن.
var array = [3, 4];
var sum = add.apply(null, array); // المجموع يساوي 7
// أنشئ كائناً بخاصية status.
var statusObject = {
 status: 'A-OK'
};
// statusObject لم يرث من Quo.prototype,
// لكن يمكننا استدعاء التابع get_status 
// على الكائن statusObject على الرغم من أنه لا يمتلك هذا التابع
var status = Quo.prototype.get_status.apply(statusObject);
 // status تساوي 'A-OK
```

### الوسائط arguments

أحد المعاملات الإضافية التي تكون متاحة للدوال عند استدعائها هي المصفوفة `arguments`. حيث تتيح الوصول الى جميع المعاملات التي تم ارسالها الى الدالة عند استدعائها، بما في ذلك الوسائط الفائضة التي لم يقابلها معامل لتسند إليه. وذلك يجعل بالإمكان كتابة دوال تستطيع استيعاب عدد غير محدد من المعاملات:

```javascript
// أنشئ دالة تقوم بجمع الكثير من الأرقام.

// لاحظ أن تعريف المتعير sum داخل
// الدالة لا يتعارض مع المتغير sum الآخر
// المعرف خارج الدالة. حيث أن الدالة
// لا ترى إلا المتغير الداخلي
var sum = function ( ) {
 var i, sum = 0;
 for (i = 0; i < arguments.length; i += 1) {
 	sum += arguments[i];
 }
 return sum;
};
document.writeln(sum(4, 8, 15, 16, 23, 42)); // 108
```

هذا ليس بالتحديد نمط مفيداً. سوف نرى في الفصل السادس كيف نظيف تابعاً مشابهاً للمصفوفات. 

وبسبب خطئ في التصميم، `arguments` في حقيقتها ليست مصفوفة. إنما هي كائن شبيه بالمصفوفات. حيث تمتلك خاصية `length` لكنها لا تملك أيً من التوابع الخاصة بالمصفوفات. سوف نرى تبعات خطئ التصميم هذا في نهاية الفصل.

### الإرجاع

عندما تستدعى الدالة، يبدأ التنفيذ من الجملة الأُولى، وينتهي عندما يصل الى خاصرة الإغلاق `{` التي تنهي جسم الدالة. وهذا يجعل الدالة ترجع التحكم الى جزء البرنامج الذي قام باستدعائها. 

الجملة  `return` يمكن أن تستخدم لجعل الدالة تقوم بالإرجاع مبكراً. وعندما تنفذ جملة `return`، تقوم الدالة بالإرجاع مباشرةً بدون تنفيذ باقي الجمل. 

الدالة دائماً ترجع قيمة، فإذا لم تحدد قيمة الإرجاع، عندها يتم إرجاع `undefined`.

إذا تم استدعاء الدالة مع السابقة `new`  ولم تكن القيمة الراجعة كائناً. عندها يتم إرجاع الكائن الجديد بدلاً من القيمة المحددة. 

### الاستثناءات(Exaptions)

تقدم الجافا سكربت آلية لمعالجة الاستثناءات، الاستثناءات هي حوادث غير اعتيادية-لكنها ليست غيرة متوقعة ابداً- تعترض المسار الطبيعي للبرنامج. عندما يتم الكشف عن مثل هذه الحوادث. يجب على برنامجك أن يرمي استثناءً:

```javascript
var add = function (a, b) {
    if (typeof a !== 'number' || typeof b !== 'number') {
        throw {
            name: 'TypeError',
            message: 'هذه الدالة تتطلب أرقاماً'
        };
    }
    return a + b;
}
```

 الجملة `throw` تقوم بقطع تنفيذ الدالة. ويجب ان يتبعها كائن استثناء يحتوي على خاصية `name` والتي تحدد نوع الاستثناء، وخاصية `message` والتي تصف الاستثناء. ويمكنك أيضاً إضافة أي خواصٍ أُخرى.

سيتم ارسال كائن الاستثناء الى البند `catch` الخاص بالجملة `try`:

```javascript
// أنشئ دالة try_it function التي تستدعي دالة add الجديدة
// بطرقية غير صحيحة.
var try_it = function ( ) {
     try {
    	 add("seven");
     } catch (e) {
     	document.writeln(e.name + ': ' + e.message);
     }
}
try_it( );
```

اذا تم رمي استثناء في كتلة الجملة `try` فسيتنقل التحكم الى البند `catch`.

الجملة `try` تمتلك بند `catch` واحدٍ فقط، والذي يستقبل جميع الاستثناءات، فإذا كانت معالجة الاستثناء تعتمد على نوعه، عندها يجب على معالج الاستثناء أن يقوم بفحص الخاصية `name` ليحدد نوع الاستثناء ويقوم بمعالجته.

### الأنواع المعززة

تسمح الجافا سكربت بتعزيز الأنواع الأساسية الخاصة بها حيث رأينا في الفصل الثالث كيف أنَّ إضافة تابع جديد لـ `Object.prototype` يجعل هذا التابع متوفراً لجميع الكائنات. هذا أيضاً ينطبق على الدوال والأرقام والسلاسل النصية والتعابير النمطية وايضاً على القيم البوليانيّة.

فعلى سبيل المثال، من خلا تعزيز `Function.prototype نستطيع أن نضيف تابع لجميع الدوال:

```javascript
Function.prototype.method = function (name, func) {
 this.prototype[name] = func;
 return this;
};
```

من خلال تعزيز الـ `Function.prototype` بالتابع `method`، لم نعد بحاجة الى كتابة اسم كلمة prototype لإضافة تابع جديد. وهذه سلبية تم إخفائها.

الجافا سكربت لا تمتلك نوعاً خاصاً بالأرقام الصحيحة، لذا يتوجب علينا في بعض الأحيان إزالة الجزء العشري من الرقم للتعامل بالأرقام الصحيحة. والطرقية التي توفرها الجافا سكربت لذالك ليست سلسة. نستطيع إصلاح ذلك بإضافة تابع الى `Number.prototype` ليقوم بذلك العمل. حيث سيستخدم إما `Math.ceil` أو `Math.floor` حسب اشارة الرقم:

```javascript
Number.method('integer', function ( ) {
 return Math[this < 0 ? 'ceil' : 'floor'](this);
});
document.writeln((-10 / 3).integer( )); // -3
```

تفتقر الجافا سكربت الى وجود تابع يقوم بحذف المسافات الزائدة في نهاية السلاسل النصيّة. هذا حل بسيط لهذه المشكلة:

```javascript
String.method('trim', function ( ) {
 return this.replace(/^\s+|\s+$/g, '');
});
document.writeln('"' + " أنيق ".trim( ) + '"');
```

يستخدم التابع `trim` التعابير النمطية لحل المشكلة. سوف نرى المزيد عنها في الفصل السابع.

يمكننا تقديم تحسينات كبيرة للغة من خلال تعزيز أنواعها. وهذا التعزيز ممكن بفضل الطبيعة الديناميكية للوراثة النماذجية. فجميع القيم تحصل مباشرةً على التوابع الجديدة حتى لو كانت هذه القيم قد أٌنشئت قبل التعزيز.

وبما أن نماذج الأنواع الأساسية عامة، فيجب أخذ الحيطة والحذر عند التعامل مع مكتبات كثيرة لتجنب التعارض بينها. وأحد طرق الدفاعية لذلك هي بالتأكد من عدم وجود التابع قبل إضافته:

```javascript
// أضف التابع وفق شروط.
Function.prototype.method = function (name, func) {
 	if (!this.prototype[name]) {
         this.prototype[name] = func;
         return this;
	 }
};
```

وهناك نقطة أُخرى أيضاً، فجملة for in تتعامل بشكل سيئ مع الخصائص. وقد رأينا بعض الطرق لتفادي هذه المشكلة في الفصل الثالث: حيث يمكننا استخدام التابع `hasOwnProperety` لاستبعاد الخصائص الموروثة، ويمكننا أيضاً قصر البحث على أنواع محددة فقط.

### التعاود

الدالة التعاوديّة هي دالة تنادي نفسها بشكل مباشر أو غير مباشر، التعاود هي تقنية برمجية قوية حيث تقوم بتقسيم المشكلة الى عدة مشاكل أصغر، كل منها يمكن حله بشكل بسيط ومباشر. بشكل عام الدالة التعاودّية تنادي نفسها لحل مشاكلها الجزئية. 

برج هانوي هي أُحجية شهيرة، حيث تحتوي على ثلاثة قضبان ومجموعة من الأقراص بأحجام مختلفة مثقوبة من المنتصف. تبدأ الأُحجية بكون جميع الأقراص مكومة في قضيب البداية حيث يوضع القرص الأصغر فوق القرص الأكبر منه. والهدف هو تحريك الكومة من قضيب البداية الى قضيب النهاية قرصاً قرصاً. بشرط أن لا يوضع قرص فوق قرص أصغر منه. وهذه الأحجية لها حل تعاوديٌ بسيط:

```javascript
var hanoi = function hanoi(disc, src, aux, dst) {
     if (disc > 0) {
         hanoi(disc - 1, src, dst, aux);
         document.writeln('حرك القرص ' + disc +
      			  ' من ' + src + ' الى ' + dst);
         hanoi(disc - 1, aux, src, dst);
     }
};

hanoi(3, 'النهاية', 'المساعد', 'البداية');
```

حيث يعطينى الحل لتحريك 3 أقراص:

```pseudocode
حرك القرص 1 من البداية الى النهاية
حرك القرص 2 من البداية الى المساعد
حرك القرص 1 من النهاية الى المساعد
حرك القرص 3 من البداية الى النهاية
حرك القرص 1 من المساعد الى البداية
حرك القرص 2 من المساعد الى النهاية
حرك القرص 1 من البداية الى النهاية
```

الدالة `hanoi` تقوم بتحريك كومة الأقراص من قضيب الى آخر بستخدام القضيب المساعد إذا احتاجت الى ذلك، حيث تقوم بتجزئة المشكلة الى ثلاث مشاكل جزئية، أولاً تقوم بإخراج القرص الأخير  من خلال تحريك باقي الأقراص فوقه الى القضيب المساعد، ثم يمكنها تحريكه الى قضيب النهاية. وبعد ذلك  تقوم بتحريك باقي الأقراص الى قضيب النهاية من خلال إعادة تنفيذ ما سبق بواسطة مناداتها لنفسها.

يمرر للدالة `hanoi` رقم القرص الذي ستحركه وأسماء القضبان الثلاثة التي ستستخدمها. وعندما تنادي نفسها، تقوم بالتعامل مع القرص التالي والذي كان فوق القرص الحالي. وفي لحظة ما سوف تنادى برقم قرص غير موجود "0" وعندها لن تفعل شيئاً، وعدم فعل شيئٍ في هذه الحالة يجعلنا واثقين من أن هذه الدالة لن تستمر بمناداة نفسها الى الأبد.

يمكن أن تكون الدوال التعاوديّة فعّالة جداً في التعامل مع التشجيرات مثل نموذج كائن المستَند( Document Object Model) أو اختصاراً DOM الخاص بالمتصفحات. حيث يعطى كل نداء تعاودي مهمة التعامل مع جزء صغير من التشجير للعمل عليه:

```javascript
// عرف دالة walk_the_DOM التي تزور جميع
// عقد التشجير بنفس ترتيب الHTML لها, حيث تبدأ
// from some given node. It invokes a function,
// passing it each node in turn. walk_the_DOM calls
// itself to process each of the child nodes.
var walk_the_DOM = function walk(node, func) {
     func(node);
     node = node.firstChild;
     while (node) {
         walk(node, func);
         node = node.nextSibling;
     }
};
// Define a getElementsByAttribute function. It
// takes an attribute name string and an optional
// matching value. It calls walk_the_DOM, passing it a
// function that looks for an attribute name in the
// node. The matching nodes are accumulated in a
// results array.
var getElementsByAttribute = function (att, value) {
     var results = [];
     walk_the_DOM(document.body, function (node) {
         var actual = node.nodeType === 1 && node.getAttribute(att);
         if (typeof actual === 'string' &&
         (actual === value || typeof value !== 'string')) {
            results.push(node);
         }
     });
     return results;
};
```

بعض اللغات توفر تحسين يدعى ذيل التعاود. ذلك يعني إذا كانت الدالة ترجع فقط ناتج استدعائها لنفسها، عندها سيتم تبديل الاستدعاء التعاودي بحلقة تكرارية، وهذا يسرع العملية جداً. مع الأسف، حالياً لا توفر الجافا سكربت هذا التحسين. ولهذا فإن دوال التي تعاود نفسها كثيراً جداً يمكن أن يفشل تنفيذها بسبب اجهاد مكدس الاستدعاء:

```javascript
// Make a factorial function with tail
// recursion. It is tail recursive because
// it returns the result of calling itself.
// JavaScript does not currently optimize this form.
var factorial = function factorial(i, a) {
     a = a || 1;
     if (i < 2) 
     	return a;
     }	
     return factorial(i - 1, a * i);
 };
document.writeln(factorial(4)); // 24
```

### النطاق

في لغات البرمجة يتحكم النطاق بمرئية المتغيرات والمعاملات ومدّة حياتها. وهذا أمر بالغ الأهمية في لغات البرمجة لأنه يقلل من تعارض الأسماء ويقدم إدارة آلية للذاكرة:

```javascript
var foo = function ( ) {
    var a = 3, b = 5;
    var bar = function ( ) {
        var b = 7, c = 11;
        // At this point, a is 3, b is 7, and c is 11
        a += b + c;
        // At this point, a is 21, b is 7, and c is 11
    };
   // At this point, a is 3, b is 5, and c is not defined
    bar( );
   // At this point, a is 21, b is 5
};
```

أغلب اللغات التي تمتلك صيغة سي (C syntax) لديها نطاق كُتَلّي. فجميع المتغيرات المُعَرّفة في كتلة -مجموعة من الجمل بين خاصرتين- غير مرئية من خارج الكتلة. والمتغير المعرف في كتلة يمكن أن يُحذَف عند انتهاء تنفيذ تلك الكتلة. وهذا أمر جيد.

لكن ومع الأسف، ليس لدى الجافا سكربت نطاق كُتَلّي مع أن صيغتها تقترح ذلك. وهذا اللُبس يمكن أن يكون مصدراً للأخطاء.

الجافا سكربت تمتلك نطاق دالّي. وذلك يعني أن المتغيرات والمعاملات المُعَرّفة في دالة لا تكون مرئية من خارجها، وأن المتغير المٌعَرَّف في أي مكان في الدالة مرئي من أي مكان في الدالة.

في كثير من اللغات الحديثة، يوصى بتأخير تعريف المتغيرات قدر الإمكان حتى يتم استخدامها، لكن هذه النصيحة تغدو سيئة في الجافا سكربت لأنها لا تملك نطاق كُتَلّي. لذا عوض عن ذلك، ينصح بتعريف جميع المتغيرات المستخدمة في دالة ما في بدايتها.

### المُغلِف

البشرى في ما يتعلق بالنطاق أن الدّوال الداخلية يمكنها أن تصل الى المتغيرات والمعاملات الخاصة بالدّالة التي عُرّفِت داخلها باستثناء `this` و `arguments`. وهذا أمرٌ سارٌ جداً.

الدالة `getElementsByAttribute` عملت بشكل صحيح، وذلك لأنها عَرَّفت المتغير `result`، والدالة الداخلية التي مُرِّرَت الى `walk_the_DOM` تستطيع وصولٌ الى ذاك المتغير.

والحالة الأكثر أهمية هي عندما تنتهي صلاحية الدالة الداخلية قبل الدالة الخارجية.

سابقاً قمنا بإنشاء الكائن `myObject` الذي يملك الخاصية `value` التابع `increment`. افرض أننا نريد حماية الخاصية `value` من التعديلات المباشرة.

بدلاً من انشاء الكائن باستخدام الكائن الحرفي، سنقوم بعمل دالة تقوم بإرجاع كائن حرفي. تلك الدالة تُعرف متغيراً باسم `value` حيث يكون مرئياً دائماً للتابعين `getValue` و`increment`، لكنه سيبقى غير مرئي لباقي البرنامج بسبب النطاق الدّالي:

```javascript
var myObject = (function ( ) {
     var value = 0;
     return {
     	increment: function (inc) {
        	 value += typeof inc === 'number' ? inc : 1;
         },
     	getValue: function ( ) {
            return value;
         }
     };
}( ));
```

نحن هنا لم نقم بإسناد دالة الى `myObject`، بل قمنا بإسناد ما يرجعه استدعاء الدالة اليه. لاحظ الـ `()` في السطر الأخير. الدالة ترجع كائناً يحوي على تابعين، وهذين التابعين يتمتعان بميزة الوصول الى التغير `value`.

الباني `Quo` الذي أنشأناه في بداية الفصل يبني كائن يملك الخاصية `ststus` والتابع `get_status`. لكن ذلك لا يبدو مهماً. لماذا نستدعي جالباً(getter method) لنصل الى خاصية يمكننا الوصول اليها مباشرةً؟ من الأجدى أن تكون الخاصية سرية(private). لذا دعنا نُعَرِف شكل آخر للباني حتى نقوم بذلك: 

```javascript
// Create a maker function called quo. It makes an
// object with a get_status method and a private
// status property.
var quo = function (status) {
     return {
         get_status: function ( ) {
        	 return status;
    	 }
     };
};
// Make an instance of quo.
var myQuo = quo("amazed");
document.writeln(myQuo.get_status( ));

```

صممت الدالة `quo` لتستخدم بدون السابقة `new`. لذا فلم يُبدأ اسمها بحرف كبير. عندما ننادي الدالة `quo`، ترجع لنا كائناً يحوي على التابع `get_status`. وقد خُزن مَرجعٌ الى ذاك الكائن في `myQuo`. وحتى بعد ارجاع الكائن، يبقى لدى التابع `get_status` ميزة الوصول الى المعامل `status` الخاص بـ `quo`. التابع `get_status` لا يملك ميزة وصول الى نسخة من المعامل، إنما لديه وصول الى المعامل نفسه. وهذا ممكن بسبب أن الدالة تمتلك وصولاً الى السياق(context) الذي عرفت فيه. وهذا ما يدعى بالمُغلف.

دعنا نأخذ مثالاً أكثر فائدة:

```javascript
// Define a function that sets a DOM node's color
// to yellow and then fades it to white.
var fade = function (node) {
     var level = 1;
     var step = function ( ) {
         var hex = level.toString(16);
         node.style.backgroundColor = '#FFFF' + hex + hex;
         if (level < 15) {
             level += 1;
             setTimeout(step, 100);
         }
     };
     setTimeout(step, 100);
};
fade(document.body);
```

قمنا بمناداة الدالة `fade` ومررنا اليها `document.body` وهي عقدة(node) أُنشئت بواسطة الوسم `<body>`. الدالة `fed` أسندت قيمة 1 الى المتغير `level` ثم عرفت الدالة `step`. ثم نادت `setTimeout` ومررت اليها الدالة `step` وقيمة وقت ب 100 ملي-ثانية. ثم قامت بالإرجاع، أي انتهت.

